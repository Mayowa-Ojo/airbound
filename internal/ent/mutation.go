// Code generated by entc, DO NOT EDIT.

package ent

import (
	"airbound/internal/ent/account"
	"airbound/internal/ent/address"
	"airbound/internal/ent/admin"
	"airbound/internal/ent/aircraft"
	"airbound/internal/ent/airline"
	"airbound/internal/ent/airport"
	"airbound/internal/ent/crew"
	"airbound/internal/ent/customer"
	"airbound/internal/ent/customtypes"
	"airbound/internal/ent/enums"
	"airbound/internal/ent/flight"
	"airbound/internal/ent/flightinstance"
	"airbound/internal/ent/flightreservation"
	"airbound/internal/ent/flightschedule"
	"airbound/internal/ent/flightseat"
	"airbound/internal/ent/frontdesk"
	"airbound/internal/ent/itenerary"
	"airbound/internal/ent/passenger"
	"airbound/internal/ent/permission"
	"airbound/internal/ent/pilot"
	"airbound/internal/ent/predicate"
	"airbound/internal/ent/role"
	"airbound/internal/ent/seat"
	"airbound/internal/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount           = "Account"
	TypeAddress           = "Address"
	TypeAdmin             = "Admin"
	TypeAircraft          = "Aircraft"
	TypeAirline           = "Airline"
	TypeAirport           = "Airport"
	TypeCrew              = "Crew"
	TypeCustomer          = "Customer"
	TypeFlight            = "Flight"
	TypeFlightInstance    = "FlightInstance"
	TypeFlightReservation = "FlightReservation"
	TypeFlightSchedule    = "FlightSchedule"
	TypeFlightSeat        = "FlightSeat"
	TypeFrontDesk         = "FrontDesk"
	TypeItenerary         = "Itenerary"
	TypePassenger         = "Passenger"
	TypePermission        = "Permission"
	TypePilot             = "Pilot"
	TypeRole              = "Role"
	TypeSeat              = "Seat"
	TypeUser              = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	account_status        *enums.AccountStatus
	password              *[]byte
	salt                  *[]byte
	two_fa_secret         *string
	two_fa_completed      *bool
	verification_token    *string
	forgot_password_token *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uuid.UUID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAccountStatus sets the "account_status" field.
func (m *AccountMutation) SetAccountStatus(es enums.AccountStatus) {
	m.account_status = &es
}

// AccountStatus returns the value of the "account_status" field in the mutation.
func (m *AccountMutation) AccountStatus() (r enums.AccountStatus, exists bool) {
	v := m.account_status
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountStatus returns the old "account_status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountStatus(ctx context.Context) (v enums.AccountStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountStatus: %w", err)
	}
	return oldValue.AccountStatus, nil
}

// ResetAccountStatus resets all changes to the "account_status" field.
func (m *AccountMutation) ResetAccountStatus() {
	m.account_status = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(b []byte) {
	m.password = &b
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r []byte, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetSalt sets the "salt" field.
func (m *AccountMutation) SetSalt(b []byte) {
	m.salt = &b
}

// Salt returns the value of the "salt" field in the mutation.
func (m *AccountMutation) Salt() (r []byte, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old "salt" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSalt(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt resets all changes to the "salt" field.
func (m *AccountMutation) ResetSalt() {
	m.salt = nil
}

// SetTwoFaSecret sets the "two_fa_secret" field.
func (m *AccountMutation) SetTwoFaSecret(s string) {
	m.two_fa_secret = &s
}

// TwoFaSecret returns the value of the "two_fa_secret" field in the mutation.
func (m *AccountMutation) TwoFaSecret() (r string, exists bool) {
	v := m.two_fa_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFaSecret returns the old "two_fa_secret" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTwoFaSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFaSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFaSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFaSecret: %w", err)
	}
	return oldValue.TwoFaSecret, nil
}

// ClearTwoFaSecret clears the value of the "two_fa_secret" field.
func (m *AccountMutation) ClearTwoFaSecret() {
	m.two_fa_secret = nil
	m.clearedFields[account.FieldTwoFaSecret] = struct{}{}
}

// TwoFaSecretCleared returns if the "two_fa_secret" field was cleared in this mutation.
func (m *AccountMutation) TwoFaSecretCleared() bool {
	_, ok := m.clearedFields[account.FieldTwoFaSecret]
	return ok
}

// ResetTwoFaSecret resets all changes to the "two_fa_secret" field.
func (m *AccountMutation) ResetTwoFaSecret() {
	m.two_fa_secret = nil
	delete(m.clearedFields, account.FieldTwoFaSecret)
}

// SetTwoFaCompleted sets the "two_fa_completed" field.
func (m *AccountMutation) SetTwoFaCompleted(b bool) {
	m.two_fa_completed = &b
}

// TwoFaCompleted returns the value of the "two_fa_completed" field in the mutation.
func (m *AccountMutation) TwoFaCompleted() (r bool, exists bool) {
	v := m.two_fa_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFaCompleted returns the old "two_fa_completed" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTwoFaCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFaCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFaCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFaCompleted: %w", err)
	}
	return oldValue.TwoFaCompleted, nil
}

// ResetTwoFaCompleted resets all changes to the "two_fa_completed" field.
func (m *AccountMutation) ResetTwoFaCompleted() {
	m.two_fa_completed = nil
}

// SetVerificationToken sets the "verification_token" field.
func (m *AccountMutation) SetVerificationToken(s string) {
	m.verification_token = &s
}

// VerificationToken returns the value of the "verification_token" field in the mutation.
func (m *AccountMutation) VerificationToken() (r string, exists bool) {
	v := m.verification_token
	if v == nil {
		return
	}
	return *v, true
}

// OldVerificationToken returns the old "verification_token" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldVerificationToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerificationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerificationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerificationToken: %w", err)
	}
	return oldValue.VerificationToken, nil
}

// ClearVerificationToken clears the value of the "verification_token" field.
func (m *AccountMutation) ClearVerificationToken() {
	m.verification_token = nil
	m.clearedFields[account.FieldVerificationToken] = struct{}{}
}

// VerificationTokenCleared returns if the "verification_token" field was cleared in this mutation.
func (m *AccountMutation) VerificationTokenCleared() bool {
	_, ok := m.clearedFields[account.FieldVerificationToken]
	return ok
}

// ResetVerificationToken resets all changes to the "verification_token" field.
func (m *AccountMutation) ResetVerificationToken() {
	m.verification_token = nil
	delete(m.clearedFields, account.FieldVerificationToken)
}

// SetForgotPasswordToken sets the "forgot_password_token" field.
func (m *AccountMutation) SetForgotPasswordToken(s string) {
	m.forgot_password_token = &s
}

// ForgotPasswordToken returns the value of the "forgot_password_token" field in the mutation.
func (m *AccountMutation) ForgotPasswordToken() (r string, exists bool) {
	v := m.forgot_password_token
	if v == nil {
		return
	}
	return *v, true
}

// OldForgotPasswordToken returns the old "forgot_password_token" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldForgotPasswordToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForgotPasswordToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForgotPasswordToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForgotPasswordToken: %w", err)
	}
	return oldValue.ForgotPasswordToken, nil
}

// ClearForgotPasswordToken clears the value of the "forgot_password_token" field.
func (m *AccountMutation) ClearForgotPasswordToken() {
	m.forgot_password_token = nil
	m.clearedFields[account.FieldForgotPasswordToken] = struct{}{}
}

// ForgotPasswordTokenCleared returns if the "forgot_password_token" field was cleared in this mutation.
func (m *AccountMutation) ForgotPasswordTokenCleared() bool {
	_, ok := m.clearedFields[account.FieldForgotPasswordToken]
	return ok
}

// ResetForgotPasswordToken resets all changes to the "forgot_password_token" field.
func (m *AccountMutation) ResetForgotPasswordToken() {
	m.forgot_password_token = nil
	delete(m.clearedFields, account.FieldForgotPasswordToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AccountMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AccountMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AccountMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AccountMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AccountMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.account_status != nil {
		fields = append(fields, account.FieldAccountStatus)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, account.FieldSalt)
	}
	if m.two_fa_secret != nil {
		fields = append(fields, account.FieldTwoFaSecret)
	}
	if m.two_fa_completed != nil {
		fields = append(fields, account.FieldTwoFaCompleted)
	}
	if m.verification_token != nil {
		fields = append(fields, account.FieldVerificationToken)
	}
	if m.forgot_password_token != nil {
		fields = append(fields, account.FieldForgotPasswordToken)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldAccountStatus:
		return m.AccountStatus()
	case account.FieldPassword:
		return m.Password()
	case account.FieldSalt:
		return m.Salt()
	case account.FieldTwoFaSecret:
		return m.TwoFaSecret()
	case account.FieldTwoFaCompleted:
		return m.TwoFaCompleted()
	case account.FieldVerificationToken:
		return m.VerificationToken()
	case account.FieldForgotPasswordToken:
		return m.ForgotPasswordToken()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldAccountStatus:
		return m.OldAccountStatus(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldSalt:
		return m.OldSalt(ctx)
	case account.FieldTwoFaSecret:
		return m.OldTwoFaSecret(ctx)
	case account.FieldTwoFaCompleted:
		return m.OldTwoFaCompleted(ctx)
	case account.FieldVerificationToken:
		return m.OldVerificationToken(ctx)
	case account.FieldForgotPasswordToken:
		return m.OldForgotPasswordToken(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldAccountStatus:
		v, ok := value.(enums.AccountStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountStatus(v)
		return nil
	case account.FieldPassword:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldSalt:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case account.FieldTwoFaSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFaSecret(v)
		return nil
	case account.FieldTwoFaCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFaCompleted(v)
		return nil
	case account.FieldVerificationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerificationToken(v)
		return nil
	case account.FieldForgotPasswordToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForgotPasswordToken(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldTwoFaSecret) {
		fields = append(fields, account.FieldTwoFaSecret)
	}
	if m.FieldCleared(account.FieldVerificationToken) {
		fields = append(fields, account.FieldVerificationToken)
	}
	if m.FieldCleared(account.FieldForgotPasswordToken) {
		fields = append(fields, account.FieldForgotPasswordToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldTwoFaSecret:
		m.ClearTwoFaSecret()
		return nil
	case account.FieldVerificationToken:
		m.ClearVerificationToken()
		return nil
	case account.FieldForgotPasswordToken:
		m.ClearForgotPasswordToken()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldAccountStatus:
		m.ResetAccountStatus()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldSalt:
		m.ResetSalt()
		return nil
	case account.FieldTwoFaSecret:
		m.ResetTwoFaSecret()
		return nil
	case account.FieldTwoFaCompleted:
		m.ResetTwoFaCompleted()
		return nil
	case account.FieldVerificationToken:
		m.ResetVerificationToken()
		return nil
	case account.FieldForgotPasswordToken:
		m.ResetForgotPasswordToken()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, account.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, account.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	street         *string
	city           *string
	state          *string
	zipcode        *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	airport        *uuid.UUID
	clearedairport bool
	done           bool
	oldValue       func(context.Context) (*Address, error)
	predicates     []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id uuid.UUID) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStreet sets the "street" field.
func (m *AddressMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *AddressMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ResetStreet resets all changes to the "street" field.
func (m *AddressMutation) ResetStreet() {
	m.street = nil
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *AddressMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AddressMutation) ResetState() {
	m.state = nil
}

// SetZipcode sets the "zipcode" field.
func (m *AddressMutation) SetZipcode(s string) {
	m.zipcode = &s
}

// Zipcode returns the value of the "zipcode" field in the mutation.
func (m *AddressMutation) Zipcode() (r string, exists bool) {
	v := m.zipcode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipcode returns the old "zipcode" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZipcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZipcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZipcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipcode: %w", err)
	}
	return oldValue.Zipcode, nil
}

// ResetZipcode resets all changes to the "zipcode" field.
func (m *AddressMutation) ResetZipcode() {
	m.zipcode = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AddressMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AddressMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AddressMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AddressMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AddressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *AddressMutation) SetAirportID(id uuid.UUID) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *AddressMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *AddressMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *AddressMutation) AirportID() (id uuid.UUID, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) AirportIDs() (ids []uuid.UUID) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *AddressMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.street != nil {
		fields = append(fields, address.FieldStreet)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, address.FieldState)
	}
	if m.zipcode != nil {
		fields = append(fields, address.FieldZipcode)
	}
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldStreet:
		return m.Street()
	case address.FieldCity:
		return m.City()
	case address.FieldState:
		return m.State()
	case address.FieldZipcode:
		return m.Zipcode()
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldStreet:
		return m.OldStreet(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldZipcode:
		return m.OldZipcode(ctx)
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldZipcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipcode(v)
		return nil
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldStreet:
		m.ResetStreet()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldZipcode:
		m.ResetZipcode()
		return nil
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, address.EdgeUser)
	}
	if m.airport != nil {
		edges = append(edges, address.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, address.EdgeUser)
	}
	if m.clearedairport {
		edges = append(edges, address.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeUser:
		return m.cleareduser
	case address.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ClearUser()
		return nil
	case address.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ResetUser()
		return nil
	case address.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AdminMutation represents an operation that mutates the Admin nodes in the graph.
type AdminMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	level             *int
	addlevel          *int
	security_question *string
	security_answer   *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Admin, error)
	predicates        []predicate.Admin
}

var _ ent.Mutation = (*AdminMutation)(nil)

// adminOption allows management of the mutation configuration using functional options.
type adminOption func(*AdminMutation)

// newAdminMutation creates new mutation for the Admin entity.
func newAdminMutation(c config, op Op, opts ...adminOption) *AdminMutation {
	m := &AdminMutation{
		config:        c,
		op:            op,
		typ:           TypeAdmin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminID sets the ID field of the mutation.
func withAdminID(id uuid.UUID) adminOption {
	return func(m *AdminMutation) {
		var (
			err   error
			once  sync.Once
			value *Admin
		)
		m.oldValue = func(ctx context.Context) (*Admin, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Admin.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdmin sets the old Admin of the mutation.
func withAdmin(node *Admin) adminOption {
	return func(m *AdminMutation) {
		m.oldValue = func(context.Context) (*Admin, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Admin entities.
func (m *AdminMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Admin.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "level" field.
func (m *AdminMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *AdminMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *AdminMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *AdminMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *AdminMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetSecurityQuestion sets the "security_question" field.
func (m *AdminMutation) SetSecurityQuestion(s string) {
	m.security_question = &s
}

// SecurityQuestion returns the value of the "security_question" field in the mutation.
func (m *AdminMutation) SecurityQuestion() (r string, exists bool) {
	v := m.security_question
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityQuestion returns the old "security_question" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldSecurityQuestion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityQuestion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityQuestion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityQuestion: %w", err)
	}
	return oldValue.SecurityQuestion, nil
}

// ClearSecurityQuestion clears the value of the "security_question" field.
func (m *AdminMutation) ClearSecurityQuestion() {
	m.security_question = nil
	m.clearedFields[admin.FieldSecurityQuestion] = struct{}{}
}

// SecurityQuestionCleared returns if the "security_question" field was cleared in this mutation.
func (m *AdminMutation) SecurityQuestionCleared() bool {
	_, ok := m.clearedFields[admin.FieldSecurityQuestion]
	return ok
}

// ResetSecurityQuestion resets all changes to the "security_question" field.
func (m *AdminMutation) ResetSecurityQuestion() {
	m.security_question = nil
	delete(m.clearedFields, admin.FieldSecurityQuestion)
}

// SetSecurityAnswer sets the "security_answer" field.
func (m *AdminMutation) SetSecurityAnswer(s string) {
	m.security_answer = &s
}

// SecurityAnswer returns the value of the "security_answer" field in the mutation.
func (m *AdminMutation) SecurityAnswer() (r string, exists bool) {
	v := m.security_answer
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityAnswer returns the old "security_answer" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldSecurityAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityAnswer: %w", err)
	}
	return oldValue.SecurityAnswer, nil
}

// ClearSecurityAnswer clears the value of the "security_answer" field.
func (m *AdminMutation) ClearSecurityAnswer() {
	m.security_answer = nil
	m.clearedFields[admin.FieldSecurityAnswer] = struct{}{}
}

// SecurityAnswerCleared returns if the "security_answer" field was cleared in this mutation.
func (m *AdminMutation) SecurityAnswerCleared() bool {
	_, ok := m.clearedFields[admin.FieldSecurityAnswer]
	return ok
}

// ResetSecurityAnswer resets all changes to the "security_answer" field.
func (m *AdminMutation) ResetSecurityAnswer() {
	m.security_answer = nil
	delete(m.clearedFields, admin.FieldSecurityAnswer)
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Admin entity.
// If the Admin object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AdminMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AdminMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AdminMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AdminMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AdminMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AdminMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AdminMutation builder.
func (m *AdminMutation) Where(ps ...predicate.Admin) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdminMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Admin).
func (m *AdminMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.level != nil {
		fields = append(fields, admin.FieldLevel)
	}
	if m.security_question != nil {
		fields = append(fields, admin.FieldSecurityQuestion)
	}
	if m.security_answer != nil {
		fields = append(fields, admin.FieldSecurityAnswer)
	}
	if m.created_at != nil {
		fields = append(fields, admin.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admin.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldLevel:
		return m.Level()
	case admin.FieldSecurityQuestion:
		return m.SecurityQuestion()
	case admin.FieldSecurityAnswer:
		return m.SecurityAnswer()
	case admin.FieldCreatedAt:
		return m.CreatedAt()
	case admin.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admin.FieldLevel:
		return m.OldLevel(ctx)
	case admin.FieldSecurityQuestion:
		return m.OldSecurityQuestion(ctx)
	case admin.FieldSecurityAnswer:
		return m.OldSecurityAnswer(ctx)
	case admin.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admin.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Admin field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admin.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case admin.FieldSecurityQuestion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityQuestion(v)
		return nil
	case admin.FieldSecurityAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityAnswer(v)
		return nil
	case admin.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admin.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, admin.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case admin.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminMutation) AddField(name string, value ent.Value) error {
	switch name {
	case admin.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Admin numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admin.FieldSecurityQuestion) {
		fields = append(fields, admin.FieldSecurityQuestion)
	}
	if m.FieldCleared(admin.FieldSecurityAnswer) {
		fields = append(fields, admin.FieldSecurityAnswer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminMutation) ClearField(name string) error {
	switch name {
	case admin.FieldSecurityQuestion:
		m.ClearSecurityQuestion()
		return nil
	case admin.FieldSecurityAnswer:
		m.ClearSecurityAnswer()
		return nil
	}
	return fmt.Errorf("unknown Admin nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminMutation) ResetField(name string) error {
	switch name {
	case admin.FieldLevel:
		m.ResetLevel()
		return nil
	case admin.FieldSecurityQuestion:
		m.ResetSecurityQuestion()
		return nil
	case admin.FieldSecurityAnswer:
		m.ResetSecurityAnswer()
		return nil
	case admin.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admin.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Admin field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, admin.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case admin.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, admin.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminMutation) EdgeCleared(name string) bool {
	switch name {
	case admin.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminMutation) ClearEdge(name string) error {
	switch name {
	case admin.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Admin unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminMutation) ResetEdge(name string) error {
	switch name {
	case admin.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Admin edge %s", name)
}

// AircraftMutation represents an operation that mutates the Aircraft nodes in the graph.
type AircraftMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	tail_number            *string
	manufacturer           *string
	model                  *string
	capacity               *int
	addcapacity            *int
	_range                 *int
	add_range              *int
	manufactured_at        *time.Time
	is_grounded            *bool
	grounded_at            *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	airline                *uuid.UUID
	clearedairline         bool
	flight_instance        *uuid.UUID
	clearedflight_instance bool
	seats                  map[uuid.UUID]struct{}
	removedseats           map[uuid.UUID]struct{}
	clearedseats           bool
	done                   bool
	oldValue               func(context.Context) (*Aircraft, error)
	predicates             []predicate.Aircraft
}

var _ ent.Mutation = (*AircraftMutation)(nil)

// aircraftOption allows management of the mutation configuration using functional options.
type aircraftOption func(*AircraftMutation)

// newAircraftMutation creates new mutation for the Aircraft entity.
func newAircraftMutation(c config, op Op, opts ...aircraftOption) *AircraftMutation {
	m := &AircraftMutation{
		config:        c,
		op:            op,
		typ:           TypeAircraft,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAircraftID sets the ID field of the mutation.
func withAircraftID(id uuid.UUID) aircraftOption {
	return func(m *AircraftMutation) {
		var (
			err   error
			once  sync.Once
			value *Aircraft
		)
		m.oldValue = func(ctx context.Context) (*Aircraft, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Aircraft.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAircraft sets the old Aircraft of the mutation.
func withAircraft(node *Aircraft) aircraftOption {
	return func(m *AircraftMutation) {
		m.oldValue = func(context.Context) (*Aircraft, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AircraftMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AircraftMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Aircraft entities.
func (m *AircraftMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AircraftMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AircraftMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Aircraft.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTailNumber sets the "tail_number" field.
func (m *AircraftMutation) SetTailNumber(s string) {
	m.tail_number = &s
}

// TailNumber returns the value of the "tail_number" field in the mutation.
func (m *AircraftMutation) TailNumber() (r string, exists bool) {
	v := m.tail_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTailNumber returns the old "tail_number" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldTailNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTailNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTailNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTailNumber: %w", err)
	}
	return oldValue.TailNumber, nil
}

// ResetTailNumber resets all changes to the "tail_number" field.
func (m *AircraftMutation) ResetTailNumber() {
	m.tail_number = nil
}

// SetManufacturer sets the "manufacturer" field.
func (m *AircraftMutation) SetManufacturer(s string) {
	m.manufacturer = &s
}

// Manufacturer returns the value of the "manufacturer" field in the mutation.
func (m *AircraftMutation) Manufacturer() (r string, exists bool) {
	v := m.manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturer returns the old "manufacturer" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturer: %w", err)
	}
	return oldValue.Manufacturer, nil
}

// ResetManufacturer resets all changes to the "manufacturer" field.
func (m *AircraftMutation) ResetManufacturer() {
	m.manufacturer = nil
}

// SetModel sets the "model" field.
func (m *AircraftMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *AircraftMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *AircraftMutation) ResetModel() {
	m.model = nil
}

// SetCapacity sets the "capacity" field.
func (m *AircraftMutation) SetCapacity(i int) {
	m.capacity = &i
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *AircraftMutation) Capacity() (r int, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldCapacity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds i to the "capacity" field.
func (m *AircraftMutation) AddCapacity(i int) {
	if m.addcapacity != nil {
		*m.addcapacity += i
	} else {
		m.addcapacity = &i
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *AircraftMutation) AddedCapacity() (r int, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *AircraftMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// SetRange sets the "range" field.
func (m *AircraftMutation) SetRange(i int) {
	m._range = &i
	m.add_range = nil
}

// Range returns the value of the "range" field in the mutation.
func (m *AircraftMutation) Range() (r int, exists bool) {
	v := m._range
	if v == nil {
		return
	}
	return *v, true
}

// OldRange returns the old "range" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldRange(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRange: %w", err)
	}
	return oldValue.Range, nil
}

// AddRange adds i to the "range" field.
func (m *AircraftMutation) AddRange(i int) {
	if m.add_range != nil {
		*m.add_range += i
	} else {
		m.add_range = &i
	}
}

// AddedRange returns the value that was added to the "range" field in this mutation.
func (m *AircraftMutation) AddedRange() (r int, exists bool) {
	v := m.add_range
	if v == nil {
		return
	}
	return *v, true
}

// ResetRange resets all changes to the "range" field.
func (m *AircraftMutation) ResetRange() {
	m._range = nil
	m.add_range = nil
}

// SetManufacturedAt sets the "manufactured_at" field.
func (m *AircraftMutation) SetManufacturedAt(t time.Time) {
	m.manufactured_at = &t
}

// ManufacturedAt returns the value of the "manufactured_at" field in the mutation.
func (m *AircraftMutation) ManufacturedAt() (r time.Time, exists bool) {
	v := m.manufactured_at
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturedAt returns the old "manufactured_at" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldManufacturedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturedAt: %w", err)
	}
	return oldValue.ManufacturedAt, nil
}

// ResetManufacturedAt resets all changes to the "manufactured_at" field.
func (m *AircraftMutation) ResetManufacturedAt() {
	m.manufactured_at = nil
}

// SetIsGrounded sets the "is_grounded" field.
func (m *AircraftMutation) SetIsGrounded(b bool) {
	m.is_grounded = &b
}

// IsGrounded returns the value of the "is_grounded" field in the mutation.
func (m *AircraftMutation) IsGrounded() (r bool, exists bool) {
	v := m.is_grounded
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGrounded returns the old "is_grounded" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldIsGrounded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGrounded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGrounded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGrounded: %w", err)
	}
	return oldValue.IsGrounded, nil
}

// ResetIsGrounded resets all changes to the "is_grounded" field.
func (m *AircraftMutation) ResetIsGrounded() {
	m.is_grounded = nil
}

// SetGroundedAt sets the "grounded_at" field.
func (m *AircraftMutation) SetGroundedAt(t time.Time) {
	m.grounded_at = &t
}

// GroundedAt returns the value of the "grounded_at" field in the mutation.
func (m *AircraftMutation) GroundedAt() (r time.Time, exists bool) {
	v := m.grounded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGroundedAt returns the old "grounded_at" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldGroundedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroundedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroundedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroundedAt: %w", err)
	}
	return oldValue.GroundedAt, nil
}

// ClearGroundedAt clears the value of the "grounded_at" field.
func (m *AircraftMutation) ClearGroundedAt() {
	m.grounded_at = nil
	m.clearedFields[aircraft.FieldGroundedAt] = struct{}{}
}

// GroundedAtCleared returns if the "grounded_at" field was cleared in this mutation.
func (m *AircraftMutation) GroundedAtCleared() bool {
	_, ok := m.clearedFields[aircraft.FieldGroundedAt]
	return ok
}

// ResetGroundedAt resets all changes to the "grounded_at" field.
func (m *AircraftMutation) ResetGroundedAt() {
	m.grounded_at = nil
	delete(m.clearedFields, aircraft.FieldGroundedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AircraftMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AircraftMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AircraftMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AircraftMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AircraftMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Aircraft entity.
// If the Aircraft object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AircraftMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AircraftMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAirlineID sets the "airline" edge to the Airline entity by id.
func (m *AircraftMutation) SetAirlineID(id uuid.UUID) {
	m.airline = &id
}

// ClearAirline clears the "airline" edge to the Airline entity.
func (m *AircraftMutation) ClearAirline() {
	m.clearedairline = true
}

// AirlineCleared reports if the "airline" edge to the Airline entity was cleared.
func (m *AircraftMutation) AirlineCleared() bool {
	return m.clearedairline
}

// AirlineID returns the "airline" edge ID in the mutation.
func (m *AircraftMutation) AirlineID() (id uuid.UUID, exists bool) {
	if m.airline != nil {
		return *m.airline, true
	}
	return
}

// AirlineIDs returns the "airline" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirlineID instead. It exists only for internal usage by the builders.
func (m *AircraftMutation) AirlineIDs() (ids []uuid.UUID) {
	if id := m.airline; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirline resets all changes to the "airline" edge.
func (m *AircraftMutation) ResetAirline() {
	m.airline = nil
	m.clearedairline = false
}

// SetFlightInstanceID sets the "flight_instance" edge to the FlightInstance entity by id.
func (m *AircraftMutation) SetFlightInstanceID(id uuid.UUID) {
	m.flight_instance = &id
}

// ClearFlightInstance clears the "flight_instance" edge to the FlightInstance entity.
func (m *AircraftMutation) ClearFlightInstance() {
	m.clearedflight_instance = true
}

// FlightInstanceCleared reports if the "flight_instance" edge to the FlightInstance entity was cleared.
func (m *AircraftMutation) FlightInstanceCleared() bool {
	return m.clearedflight_instance
}

// FlightInstanceID returns the "flight_instance" edge ID in the mutation.
func (m *AircraftMutation) FlightInstanceID() (id uuid.UUID, exists bool) {
	if m.flight_instance != nil {
		return *m.flight_instance, true
	}
	return
}

// FlightInstanceIDs returns the "flight_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightInstanceID instead. It exists only for internal usage by the builders.
func (m *AircraftMutation) FlightInstanceIDs() (ids []uuid.UUID) {
	if id := m.flight_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightInstance resets all changes to the "flight_instance" edge.
func (m *AircraftMutation) ResetFlightInstance() {
	m.flight_instance = nil
	m.clearedflight_instance = false
}

// AddSeatIDs adds the "seats" edge to the Seat entity by ids.
func (m *AircraftMutation) AddSeatIDs(ids ...uuid.UUID) {
	if m.seats == nil {
		m.seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.seats[ids[i]] = struct{}{}
	}
}

// ClearSeats clears the "seats" edge to the Seat entity.
func (m *AircraftMutation) ClearSeats() {
	m.clearedseats = true
}

// SeatsCleared reports if the "seats" edge to the Seat entity was cleared.
func (m *AircraftMutation) SeatsCleared() bool {
	return m.clearedseats
}

// RemoveSeatIDs removes the "seats" edge to the Seat entity by IDs.
func (m *AircraftMutation) RemoveSeatIDs(ids ...uuid.UUID) {
	if m.removedseats == nil {
		m.removedseats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.seats, ids[i])
		m.removedseats[ids[i]] = struct{}{}
	}
}

// RemovedSeats returns the removed IDs of the "seats" edge to the Seat entity.
func (m *AircraftMutation) RemovedSeatsIDs() (ids []uuid.UUID) {
	for id := range m.removedseats {
		ids = append(ids, id)
	}
	return
}

// SeatsIDs returns the "seats" edge IDs in the mutation.
func (m *AircraftMutation) SeatsIDs() (ids []uuid.UUID) {
	for id := range m.seats {
		ids = append(ids, id)
	}
	return
}

// ResetSeats resets all changes to the "seats" edge.
func (m *AircraftMutation) ResetSeats() {
	m.seats = nil
	m.clearedseats = false
	m.removedseats = nil
}

// Where appends a list predicates to the AircraftMutation builder.
func (m *AircraftMutation) Where(ps ...predicate.Aircraft) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AircraftMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Aircraft).
func (m *AircraftMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AircraftMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.tail_number != nil {
		fields = append(fields, aircraft.FieldTailNumber)
	}
	if m.manufacturer != nil {
		fields = append(fields, aircraft.FieldManufacturer)
	}
	if m.model != nil {
		fields = append(fields, aircraft.FieldModel)
	}
	if m.capacity != nil {
		fields = append(fields, aircraft.FieldCapacity)
	}
	if m._range != nil {
		fields = append(fields, aircraft.FieldRange)
	}
	if m.manufactured_at != nil {
		fields = append(fields, aircraft.FieldManufacturedAt)
	}
	if m.is_grounded != nil {
		fields = append(fields, aircraft.FieldIsGrounded)
	}
	if m.grounded_at != nil {
		fields = append(fields, aircraft.FieldGroundedAt)
	}
	if m.created_at != nil {
		fields = append(fields, aircraft.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, aircraft.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AircraftMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case aircraft.FieldTailNumber:
		return m.TailNumber()
	case aircraft.FieldManufacturer:
		return m.Manufacturer()
	case aircraft.FieldModel:
		return m.Model()
	case aircraft.FieldCapacity:
		return m.Capacity()
	case aircraft.FieldRange:
		return m.Range()
	case aircraft.FieldManufacturedAt:
		return m.ManufacturedAt()
	case aircraft.FieldIsGrounded:
		return m.IsGrounded()
	case aircraft.FieldGroundedAt:
		return m.GroundedAt()
	case aircraft.FieldCreatedAt:
		return m.CreatedAt()
	case aircraft.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AircraftMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case aircraft.FieldTailNumber:
		return m.OldTailNumber(ctx)
	case aircraft.FieldManufacturer:
		return m.OldManufacturer(ctx)
	case aircraft.FieldModel:
		return m.OldModel(ctx)
	case aircraft.FieldCapacity:
		return m.OldCapacity(ctx)
	case aircraft.FieldRange:
		return m.OldRange(ctx)
	case aircraft.FieldManufacturedAt:
		return m.OldManufacturedAt(ctx)
	case aircraft.FieldIsGrounded:
		return m.OldIsGrounded(ctx)
	case aircraft.FieldGroundedAt:
		return m.OldGroundedAt(ctx)
	case aircraft.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case aircraft.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Aircraft field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AircraftMutation) SetField(name string, value ent.Value) error {
	switch name {
	case aircraft.FieldTailNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTailNumber(v)
		return nil
	case aircraft.FieldManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturer(v)
		return nil
	case aircraft.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case aircraft.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	case aircraft.FieldRange:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRange(v)
		return nil
	case aircraft.FieldManufacturedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturedAt(v)
		return nil
	case aircraft.FieldIsGrounded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGrounded(v)
		return nil
	case aircraft.FieldGroundedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroundedAt(v)
		return nil
	case aircraft.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case aircraft.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Aircraft field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AircraftMutation) AddedFields() []string {
	var fields []string
	if m.addcapacity != nil {
		fields = append(fields, aircraft.FieldCapacity)
	}
	if m.add_range != nil {
		fields = append(fields, aircraft.FieldRange)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AircraftMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case aircraft.FieldCapacity:
		return m.AddedCapacity()
	case aircraft.FieldRange:
		return m.AddedRange()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AircraftMutation) AddField(name string, value ent.Value) error {
	switch name {
	case aircraft.FieldCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	case aircraft.FieldRange:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRange(v)
		return nil
	}
	return fmt.Errorf("unknown Aircraft numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AircraftMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(aircraft.FieldGroundedAt) {
		fields = append(fields, aircraft.FieldGroundedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AircraftMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AircraftMutation) ClearField(name string) error {
	switch name {
	case aircraft.FieldGroundedAt:
		m.ClearGroundedAt()
		return nil
	}
	return fmt.Errorf("unknown Aircraft nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AircraftMutation) ResetField(name string) error {
	switch name {
	case aircraft.FieldTailNumber:
		m.ResetTailNumber()
		return nil
	case aircraft.FieldManufacturer:
		m.ResetManufacturer()
		return nil
	case aircraft.FieldModel:
		m.ResetModel()
		return nil
	case aircraft.FieldCapacity:
		m.ResetCapacity()
		return nil
	case aircraft.FieldRange:
		m.ResetRange()
		return nil
	case aircraft.FieldManufacturedAt:
		m.ResetManufacturedAt()
		return nil
	case aircraft.FieldIsGrounded:
		m.ResetIsGrounded()
		return nil
	case aircraft.FieldGroundedAt:
		m.ResetGroundedAt()
		return nil
	case aircraft.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case aircraft.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Aircraft field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AircraftMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.airline != nil {
		edges = append(edges, aircraft.EdgeAirline)
	}
	if m.flight_instance != nil {
		edges = append(edges, aircraft.EdgeFlightInstance)
	}
	if m.seats != nil {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AircraftMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case aircraft.EdgeAirline:
		if id := m.airline; id != nil {
			return []ent.Value{*id}
		}
	case aircraft.EdgeFlightInstance:
		if id := m.flight_instance; id != nil {
			return []ent.Value{*id}
		}
	case aircraft.EdgeSeats:
		ids := make([]ent.Value, 0, len(m.seats))
		for id := range m.seats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AircraftMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedseats != nil {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AircraftMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case aircraft.EdgeSeats:
		ids := make([]ent.Value, 0, len(m.removedseats))
		for id := range m.removedseats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AircraftMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedairline {
		edges = append(edges, aircraft.EdgeAirline)
	}
	if m.clearedflight_instance {
		edges = append(edges, aircraft.EdgeFlightInstance)
	}
	if m.clearedseats {
		edges = append(edges, aircraft.EdgeSeats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AircraftMutation) EdgeCleared(name string) bool {
	switch name {
	case aircraft.EdgeAirline:
		return m.clearedairline
	case aircraft.EdgeFlightInstance:
		return m.clearedflight_instance
	case aircraft.EdgeSeats:
		return m.clearedseats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AircraftMutation) ClearEdge(name string) error {
	switch name {
	case aircraft.EdgeAirline:
		m.ClearAirline()
		return nil
	case aircraft.EdgeFlightInstance:
		m.ClearFlightInstance()
		return nil
	}
	return fmt.Errorf("unknown Aircraft unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AircraftMutation) ResetEdge(name string) error {
	switch name {
	case aircraft.EdgeAirline:
		m.ResetAirline()
		return nil
	case aircraft.EdgeFlightInstance:
		m.ResetFlightInstance()
		return nil
	case aircraft.EdgeSeats:
		m.ResetSeats()
		return nil
	}
	return fmt.Errorf("unknown Aircraft edge %s", name)
}

// AirlineMutation represents an operation that mutates the Airline nodes in the graph.
type AirlineMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	iata_code        *string
	icao_code        *string
	call_sign        *string
	country          *string
	license_code     *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	aircrafts        map[uuid.UUID]struct{}
	removedaircrafts map[uuid.UUID]struct{}
	clearedaircrafts bool
	crews            map[uuid.UUID]struct{}
	removedcrews     map[uuid.UUID]struct{}
	clearedcrews     bool
	pilots           map[uuid.UUID]struct{}
	removedpilots    map[uuid.UUID]struct{}
	clearedpilots    bool
	flights          map[uuid.UUID]struct{}
	removedflights   map[uuid.UUID]struct{}
	clearedflights   bool
	done             bool
	oldValue         func(context.Context) (*Airline, error)
	predicates       []predicate.Airline
}

var _ ent.Mutation = (*AirlineMutation)(nil)

// airlineOption allows management of the mutation configuration using functional options.
type airlineOption func(*AirlineMutation)

// newAirlineMutation creates new mutation for the Airline entity.
func newAirlineMutation(c config, op Op, opts ...airlineOption) *AirlineMutation {
	m := &AirlineMutation{
		config:        c,
		op:            op,
		typ:           TypeAirline,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirlineID sets the ID field of the mutation.
func withAirlineID(id uuid.UUID) airlineOption {
	return func(m *AirlineMutation) {
		var (
			err   error
			once  sync.Once
			value *Airline
		)
		m.oldValue = func(ctx context.Context) (*Airline, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airline.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirline sets the old Airline of the mutation.
func withAirline(node *Airline) airlineOption {
	return func(m *AirlineMutation) {
		m.oldValue = func(context.Context) (*Airline, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirlineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirlineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Airline entities.
func (m *AirlineMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirlineMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirlineMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airline.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AirlineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirlineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirlineMutation) ResetName() {
	m.name = nil
}

// SetIataCode sets the "iata_code" field.
func (m *AirlineMutation) SetIataCode(s string) {
	m.iata_code = &s
}

// IataCode returns the value of the "iata_code" field in the mutation.
func (m *AirlineMutation) IataCode() (r string, exists bool) {
	v := m.iata_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIataCode returns the old "iata_code" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldIataCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIataCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIataCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIataCode: %w", err)
	}
	return oldValue.IataCode, nil
}

// ResetIataCode resets all changes to the "iata_code" field.
func (m *AirlineMutation) ResetIataCode() {
	m.iata_code = nil
}

// SetIcaoCode sets the "icao_code" field.
func (m *AirlineMutation) SetIcaoCode(s string) {
	m.icao_code = &s
}

// IcaoCode returns the value of the "icao_code" field in the mutation.
func (m *AirlineMutation) IcaoCode() (r string, exists bool) {
	v := m.icao_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIcaoCode returns the old "icao_code" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldIcaoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcaoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcaoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcaoCode: %w", err)
	}
	return oldValue.IcaoCode, nil
}

// ResetIcaoCode resets all changes to the "icao_code" field.
func (m *AirlineMutation) ResetIcaoCode() {
	m.icao_code = nil
}

// SetCallSign sets the "call_sign" field.
func (m *AirlineMutation) SetCallSign(s string) {
	m.call_sign = &s
}

// CallSign returns the value of the "call_sign" field in the mutation.
func (m *AirlineMutation) CallSign() (r string, exists bool) {
	v := m.call_sign
	if v == nil {
		return
	}
	return *v, true
}

// OldCallSign returns the old "call_sign" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldCallSign(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallSign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallSign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallSign: %w", err)
	}
	return oldValue.CallSign, nil
}

// ResetCallSign resets all changes to the "call_sign" field.
func (m *AirlineMutation) ResetCallSign() {
	m.call_sign = nil
}

// SetCountry sets the "country" field.
func (m *AirlineMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *AirlineMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *AirlineMutation) ResetCountry() {
	m.country = nil
}

// SetLicenseCode sets the "license_code" field.
func (m *AirlineMutation) SetLicenseCode(s string) {
	m.license_code = &s
}

// LicenseCode returns the value of the "license_code" field in the mutation.
func (m *AirlineMutation) LicenseCode() (r string, exists bool) {
	v := m.license_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseCode returns the old "license_code" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldLicenseCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseCode: %w", err)
	}
	return oldValue.LicenseCode, nil
}

// ResetLicenseCode resets all changes to the "license_code" field.
func (m *AirlineMutation) ResetLicenseCode() {
	m.license_code = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AirlineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AirlineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AirlineMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AirlineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AirlineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Airline entity.
// If the Airline object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirlineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AirlineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddAircraftIDs adds the "aircrafts" edge to the Aircraft entity by ids.
func (m *AirlineMutation) AddAircraftIDs(ids ...uuid.UUID) {
	if m.aircrafts == nil {
		m.aircrafts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.aircrafts[ids[i]] = struct{}{}
	}
}

// ClearAircrafts clears the "aircrafts" edge to the Aircraft entity.
func (m *AirlineMutation) ClearAircrafts() {
	m.clearedaircrafts = true
}

// AircraftsCleared reports if the "aircrafts" edge to the Aircraft entity was cleared.
func (m *AirlineMutation) AircraftsCleared() bool {
	return m.clearedaircrafts
}

// RemoveAircraftIDs removes the "aircrafts" edge to the Aircraft entity by IDs.
func (m *AirlineMutation) RemoveAircraftIDs(ids ...uuid.UUID) {
	if m.removedaircrafts == nil {
		m.removedaircrafts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.aircrafts, ids[i])
		m.removedaircrafts[ids[i]] = struct{}{}
	}
}

// RemovedAircrafts returns the removed IDs of the "aircrafts" edge to the Aircraft entity.
func (m *AirlineMutation) RemovedAircraftsIDs() (ids []uuid.UUID) {
	for id := range m.removedaircrafts {
		ids = append(ids, id)
	}
	return
}

// AircraftsIDs returns the "aircrafts" edge IDs in the mutation.
func (m *AirlineMutation) AircraftsIDs() (ids []uuid.UUID) {
	for id := range m.aircrafts {
		ids = append(ids, id)
	}
	return
}

// ResetAircrafts resets all changes to the "aircrafts" edge.
func (m *AirlineMutation) ResetAircrafts() {
	m.aircrafts = nil
	m.clearedaircrafts = false
	m.removedaircrafts = nil
}

// AddCrewIDs adds the "crews" edge to the Crew entity by ids.
func (m *AirlineMutation) AddCrewIDs(ids ...uuid.UUID) {
	if m.crews == nil {
		m.crews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.crews[ids[i]] = struct{}{}
	}
}

// ClearCrews clears the "crews" edge to the Crew entity.
func (m *AirlineMutation) ClearCrews() {
	m.clearedcrews = true
}

// CrewsCleared reports if the "crews" edge to the Crew entity was cleared.
func (m *AirlineMutation) CrewsCleared() bool {
	return m.clearedcrews
}

// RemoveCrewIDs removes the "crews" edge to the Crew entity by IDs.
func (m *AirlineMutation) RemoveCrewIDs(ids ...uuid.UUID) {
	if m.removedcrews == nil {
		m.removedcrews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.crews, ids[i])
		m.removedcrews[ids[i]] = struct{}{}
	}
}

// RemovedCrews returns the removed IDs of the "crews" edge to the Crew entity.
func (m *AirlineMutation) RemovedCrewsIDs() (ids []uuid.UUID) {
	for id := range m.removedcrews {
		ids = append(ids, id)
	}
	return
}

// CrewsIDs returns the "crews" edge IDs in the mutation.
func (m *AirlineMutation) CrewsIDs() (ids []uuid.UUID) {
	for id := range m.crews {
		ids = append(ids, id)
	}
	return
}

// ResetCrews resets all changes to the "crews" edge.
func (m *AirlineMutation) ResetCrews() {
	m.crews = nil
	m.clearedcrews = false
	m.removedcrews = nil
}

// AddPilotIDs adds the "pilots" edge to the Pilot entity by ids.
func (m *AirlineMutation) AddPilotIDs(ids ...uuid.UUID) {
	if m.pilots == nil {
		m.pilots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.pilots[ids[i]] = struct{}{}
	}
}

// ClearPilots clears the "pilots" edge to the Pilot entity.
func (m *AirlineMutation) ClearPilots() {
	m.clearedpilots = true
}

// PilotsCleared reports if the "pilots" edge to the Pilot entity was cleared.
func (m *AirlineMutation) PilotsCleared() bool {
	return m.clearedpilots
}

// RemovePilotIDs removes the "pilots" edge to the Pilot entity by IDs.
func (m *AirlineMutation) RemovePilotIDs(ids ...uuid.UUID) {
	if m.removedpilots == nil {
		m.removedpilots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.pilots, ids[i])
		m.removedpilots[ids[i]] = struct{}{}
	}
}

// RemovedPilots returns the removed IDs of the "pilots" edge to the Pilot entity.
func (m *AirlineMutation) RemovedPilotsIDs() (ids []uuid.UUID) {
	for id := range m.removedpilots {
		ids = append(ids, id)
	}
	return
}

// PilotsIDs returns the "pilots" edge IDs in the mutation.
func (m *AirlineMutation) PilotsIDs() (ids []uuid.UUID) {
	for id := range m.pilots {
		ids = append(ids, id)
	}
	return
}

// ResetPilots resets all changes to the "pilots" edge.
func (m *AirlineMutation) ResetPilots() {
	m.pilots = nil
	m.clearedpilots = false
	m.removedpilots = nil
}

// AddFlightIDs adds the "flights" edge to the Flight entity by ids.
func (m *AirlineMutation) AddFlightIDs(ids ...uuid.UUID) {
	if m.flights == nil {
		m.flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flights[ids[i]] = struct{}{}
	}
}

// ClearFlights clears the "flights" edge to the Flight entity.
func (m *AirlineMutation) ClearFlights() {
	m.clearedflights = true
}

// FlightsCleared reports if the "flights" edge to the Flight entity was cleared.
func (m *AirlineMutation) FlightsCleared() bool {
	return m.clearedflights
}

// RemoveFlightIDs removes the "flights" edge to the Flight entity by IDs.
func (m *AirlineMutation) RemoveFlightIDs(ids ...uuid.UUID) {
	if m.removedflights == nil {
		m.removedflights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flights, ids[i])
		m.removedflights[ids[i]] = struct{}{}
	}
}

// RemovedFlights returns the removed IDs of the "flights" edge to the Flight entity.
func (m *AirlineMutation) RemovedFlightsIDs() (ids []uuid.UUID) {
	for id := range m.removedflights {
		ids = append(ids, id)
	}
	return
}

// FlightsIDs returns the "flights" edge IDs in the mutation.
func (m *AirlineMutation) FlightsIDs() (ids []uuid.UUID) {
	for id := range m.flights {
		ids = append(ids, id)
	}
	return
}

// ResetFlights resets all changes to the "flights" edge.
func (m *AirlineMutation) ResetFlights() {
	m.flights = nil
	m.clearedflights = false
	m.removedflights = nil
}

// Where appends a list predicates to the AirlineMutation builder.
func (m *AirlineMutation) Where(ps ...predicate.Airline) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AirlineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Airline).
func (m *AirlineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirlineMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, airline.FieldName)
	}
	if m.iata_code != nil {
		fields = append(fields, airline.FieldIataCode)
	}
	if m.icao_code != nil {
		fields = append(fields, airline.FieldIcaoCode)
	}
	if m.call_sign != nil {
		fields = append(fields, airline.FieldCallSign)
	}
	if m.country != nil {
		fields = append(fields, airline.FieldCountry)
	}
	if m.license_code != nil {
		fields = append(fields, airline.FieldLicenseCode)
	}
	if m.created_at != nil {
		fields = append(fields, airline.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, airline.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirlineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airline.FieldName:
		return m.Name()
	case airline.FieldIataCode:
		return m.IataCode()
	case airline.FieldIcaoCode:
		return m.IcaoCode()
	case airline.FieldCallSign:
		return m.CallSign()
	case airline.FieldCountry:
		return m.Country()
	case airline.FieldLicenseCode:
		return m.LicenseCode()
	case airline.FieldCreatedAt:
		return m.CreatedAt()
	case airline.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirlineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airline.FieldName:
		return m.OldName(ctx)
	case airline.FieldIataCode:
		return m.OldIataCode(ctx)
	case airline.FieldIcaoCode:
		return m.OldIcaoCode(ctx)
	case airline.FieldCallSign:
		return m.OldCallSign(ctx)
	case airline.FieldCountry:
		return m.OldCountry(ctx)
	case airline.FieldLicenseCode:
		return m.OldLicenseCode(ctx)
	case airline.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case airline.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Airline field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirlineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airline.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airline.FieldIataCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIataCode(v)
		return nil
	case airline.FieldIcaoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcaoCode(v)
		return nil
	case airline.FieldCallSign:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallSign(v)
		return nil
	case airline.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case airline.FieldLicenseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseCode(v)
		return nil
	case airline.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case airline.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Airline field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirlineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirlineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirlineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Airline numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirlineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirlineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirlineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airline nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirlineMutation) ResetField(name string) error {
	switch name {
	case airline.FieldName:
		m.ResetName()
		return nil
	case airline.FieldIataCode:
		m.ResetIataCode()
		return nil
	case airline.FieldIcaoCode:
		m.ResetIcaoCode()
		return nil
	case airline.FieldCallSign:
		m.ResetCallSign()
		return nil
	case airline.FieldCountry:
		m.ResetCountry()
		return nil
	case airline.FieldLicenseCode:
		m.ResetLicenseCode()
		return nil
	case airline.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case airline.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Airline field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirlineMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.aircrafts != nil {
		edges = append(edges, airline.EdgeAircrafts)
	}
	if m.crews != nil {
		edges = append(edges, airline.EdgeCrews)
	}
	if m.pilots != nil {
		edges = append(edges, airline.EdgePilots)
	}
	if m.flights != nil {
		edges = append(edges, airline.EdgeFlights)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirlineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airline.EdgeAircrafts:
		ids := make([]ent.Value, 0, len(m.aircrafts))
		for id := range m.aircrafts {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgeCrews:
		ids := make([]ent.Value, 0, len(m.crews))
		for id := range m.crews {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgePilots:
		ids := make([]ent.Value, 0, len(m.pilots))
		for id := range m.pilots {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.flights))
		for id := range m.flights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirlineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaircrafts != nil {
		edges = append(edges, airline.EdgeAircrafts)
	}
	if m.removedcrews != nil {
		edges = append(edges, airline.EdgeCrews)
	}
	if m.removedpilots != nil {
		edges = append(edges, airline.EdgePilots)
	}
	if m.removedflights != nil {
		edges = append(edges, airline.EdgeFlights)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirlineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airline.EdgeAircrafts:
		ids := make([]ent.Value, 0, len(m.removedaircrafts))
		for id := range m.removedaircrafts {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgeCrews:
		ids := make([]ent.Value, 0, len(m.removedcrews))
		for id := range m.removedcrews {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgePilots:
		ids := make([]ent.Value, 0, len(m.removedpilots))
		for id := range m.removedpilots {
			ids = append(ids, id)
		}
		return ids
	case airline.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.removedflights))
		for id := range m.removedflights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirlineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaircrafts {
		edges = append(edges, airline.EdgeAircrafts)
	}
	if m.clearedcrews {
		edges = append(edges, airline.EdgeCrews)
	}
	if m.clearedpilots {
		edges = append(edges, airline.EdgePilots)
	}
	if m.clearedflights {
		edges = append(edges, airline.EdgeFlights)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirlineMutation) EdgeCleared(name string) bool {
	switch name {
	case airline.EdgeAircrafts:
		return m.clearedaircrafts
	case airline.EdgeCrews:
		return m.clearedcrews
	case airline.EdgePilots:
		return m.clearedpilots
	case airline.EdgeFlights:
		return m.clearedflights
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirlineMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Airline unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirlineMutation) ResetEdge(name string) error {
	switch name {
	case airline.EdgeAircrafts:
		m.ResetAircrafts()
		return nil
	case airline.EdgeCrews:
		m.ResetCrews()
		return nil
	case airline.EdgePilots:
		m.ResetPilots()
		return nil
	case airline.EdgeFlights:
		m.ResetFlights()
		return nil
	}
	return fmt.Errorf("unknown Airline edge %s", name)
}

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	name                           *string
	iata_code                      *string
	icao_code                      *string
	elevation                      *int
	addelevation                   *int
	terminals                      *int
	addterminals                   *int
	runways                        *int
	addrunways                     *int
	created_at                     *time.Time
	updated_at                     *time.Time
	clearedFields                  map[string]struct{}
	address                        *uuid.UUID
	clearedaddress                 bool
	front_desks                    map[uuid.UUID]struct{}
	removedfront_desks             map[uuid.UUID]struct{}
	clearedfront_desks             bool
	departure_flights              map[uuid.UUID]struct{}
	removeddeparture_flights       map[uuid.UUID]struct{}
	cleareddeparture_flights       bool
	arrival_flights                map[uuid.UUID]struct{}
	removedarrival_flights         map[uuid.UUID]struct{}
	clearedarrival_flights         bool
	origin_iteneraries             map[uuid.UUID]struct{}
	removedorigin_iteneraries      map[uuid.UUID]struct{}
	clearedorigin_iteneraries      bool
	destination_iteneraries        map[uuid.UUID]struct{}
	removeddestination_iteneraries map[uuid.UUID]struct{}
	cleareddestination_iteneraries bool
	done                           bool
	oldValue                       func(context.Context) (*Airport, error)
	predicates                     []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id uuid.UUID) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Airport entities.
func (m *AirportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetIataCode sets the "iata_code" field.
func (m *AirportMutation) SetIataCode(s string) {
	m.iata_code = &s
}

// IataCode returns the value of the "iata_code" field in the mutation.
func (m *AirportMutation) IataCode() (r string, exists bool) {
	v := m.iata_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIataCode returns the old "iata_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIataCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIataCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIataCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIataCode: %w", err)
	}
	return oldValue.IataCode, nil
}

// ResetIataCode resets all changes to the "iata_code" field.
func (m *AirportMutation) ResetIataCode() {
	m.iata_code = nil
}

// SetIcaoCode sets the "icao_code" field.
func (m *AirportMutation) SetIcaoCode(s string) {
	m.icao_code = &s
}

// IcaoCode returns the value of the "icao_code" field in the mutation.
func (m *AirportMutation) IcaoCode() (r string, exists bool) {
	v := m.icao_code
	if v == nil {
		return
	}
	return *v, true
}

// OldIcaoCode returns the old "icao_code" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldIcaoCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcaoCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcaoCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcaoCode: %w", err)
	}
	return oldValue.IcaoCode, nil
}

// ResetIcaoCode resets all changes to the "icao_code" field.
func (m *AirportMutation) ResetIcaoCode() {
	m.icao_code = nil
}

// SetElevation sets the "elevation" field.
func (m *AirportMutation) SetElevation(i int) {
	m.elevation = &i
	m.addelevation = nil
}

// Elevation returns the value of the "elevation" field in the mutation.
func (m *AirportMutation) Elevation() (r int, exists bool) {
	v := m.elevation
	if v == nil {
		return
	}
	return *v, true
}

// OldElevation returns the old "elevation" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldElevation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElevation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElevation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElevation: %w", err)
	}
	return oldValue.Elevation, nil
}

// AddElevation adds i to the "elevation" field.
func (m *AirportMutation) AddElevation(i int) {
	if m.addelevation != nil {
		*m.addelevation += i
	} else {
		m.addelevation = &i
	}
}

// AddedElevation returns the value that was added to the "elevation" field in this mutation.
func (m *AirportMutation) AddedElevation() (r int, exists bool) {
	v := m.addelevation
	if v == nil {
		return
	}
	return *v, true
}

// ResetElevation resets all changes to the "elevation" field.
func (m *AirportMutation) ResetElevation() {
	m.elevation = nil
	m.addelevation = nil
}

// SetTerminals sets the "terminals" field.
func (m *AirportMutation) SetTerminals(i int) {
	m.terminals = &i
	m.addterminals = nil
}

// Terminals returns the value of the "terminals" field in the mutation.
func (m *AirportMutation) Terminals() (r int, exists bool) {
	v := m.terminals
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminals returns the old "terminals" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldTerminals(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminals: %w", err)
	}
	return oldValue.Terminals, nil
}

// AddTerminals adds i to the "terminals" field.
func (m *AirportMutation) AddTerminals(i int) {
	if m.addterminals != nil {
		*m.addterminals += i
	} else {
		m.addterminals = &i
	}
}

// AddedTerminals returns the value that was added to the "terminals" field in this mutation.
func (m *AirportMutation) AddedTerminals() (r int, exists bool) {
	v := m.addterminals
	if v == nil {
		return
	}
	return *v, true
}

// ResetTerminals resets all changes to the "terminals" field.
func (m *AirportMutation) ResetTerminals() {
	m.terminals = nil
	m.addterminals = nil
}

// SetRunways sets the "runways" field.
func (m *AirportMutation) SetRunways(i int) {
	m.runways = &i
	m.addrunways = nil
}

// Runways returns the value of the "runways" field in the mutation.
func (m *AirportMutation) Runways() (r int, exists bool) {
	v := m.runways
	if v == nil {
		return
	}
	return *v, true
}

// OldRunways returns the old "runways" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldRunways(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunways is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunways requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunways: %w", err)
	}
	return oldValue.Runways, nil
}

// AddRunways adds i to the "runways" field.
func (m *AirportMutation) AddRunways(i int) {
	if m.addrunways != nil {
		*m.addrunways += i
	} else {
		m.addrunways = &i
	}
}

// AddedRunways returns the value that was added to the "runways" field in this mutation.
func (m *AirportMutation) AddedRunways() (r int, exists bool) {
	v := m.addrunways
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunways resets all changes to the "runways" field.
func (m *AirportMutation) ResetRunways() {
	m.runways = nil
	m.addrunways = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AirportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AirportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AirportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AirportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AirportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AirportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *AirportMutation) SetAddressID(id uuid.UUID) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *AirportMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *AirportMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *AirportMutation) AddressID() (id uuid.UUID, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *AirportMutation) AddressIDs() (ids []uuid.UUID) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *AirportMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// AddFrontDeskIDs adds the "front_desks" edge to the FrontDesk entity by ids.
func (m *AirportMutation) AddFrontDeskIDs(ids ...uuid.UUID) {
	if m.front_desks == nil {
		m.front_desks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.front_desks[ids[i]] = struct{}{}
	}
}

// ClearFrontDesks clears the "front_desks" edge to the FrontDesk entity.
func (m *AirportMutation) ClearFrontDesks() {
	m.clearedfront_desks = true
}

// FrontDesksCleared reports if the "front_desks" edge to the FrontDesk entity was cleared.
func (m *AirportMutation) FrontDesksCleared() bool {
	return m.clearedfront_desks
}

// RemoveFrontDeskIDs removes the "front_desks" edge to the FrontDesk entity by IDs.
func (m *AirportMutation) RemoveFrontDeskIDs(ids ...uuid.UUID) {
	if m.removedfront_desks == nil {
		m.removedfront_desks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.front_desks, ids[i])
		m.removedfront_desks[ids[i]] = struct{}{}
	}
}

// RemovedFrontDesks returns the removed IDs of the "front_desks" edge to the FrontDesk entity.
func (m *AirportMutation) RemovedFrontDesksIDs() (ids []uuid.UUID) {
	for id := range m.removedfront_desks {
		ids = append(ids, id)
	}
	return
}

// FrontDesksIDs returns the "front_desks" edge IDs in the mutation.
func (m *AirportMutation) FrontDesksIDs() (ids []uuid.UUID) {
	for id := range m.front_desks {
		ids = append(ids, id)
	}
	return
}

// ResetFrontDesks resets all changes to the "front_desks" edge.
func (m *AirportMutation) ResetFrontDesks() {
	m.front_desks = nil
	m.clearedfront_desks = false
	m.removedfront_desks = nil
}

// AddDepartureFlightIDs adds the "departure_flights" edge to the Flight entity by ids.
func (m *AirportMutation) AddDepartureFlightIDs(ids ...uuid.UUID) {
	if m.departure_flights == nil {
		m.departure_flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.departure_flights[ids[i]] = struct{}{}
	}
}

// ClearDepartureFlights clears the "departure_flights" edge to the Flight entity.
func (m *AirportMutation) ClearDepartureFlights() {
	m.cleareddeparture_flights = true
}

// DepartureFlightsCleared reports if the "departure_flights" edge to the Flight entity was cleared.
func (m *AirportMutation) DepartureFlightsCleared() bool {
	return m.cleareddeparture_flights
}

// RemoveDepartureFlightIDs removes the "departure_flights" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveDepartureFlightIDs(ids ...uuid.UUID) {
	if m.removeddeparture_flights == nil {
		m.removeddeparture_flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.departure_flights, ids[i])
		m.removeddeparture_flights[ids[i]] = struct{}{}
	}
}

// RemovedDepartureFlights returns the removed IDs of the "departure_flights" edge to the Flight entity.
func (m *AirportMutation) RemovedDepartureFlightsIDs() (ids []uuid.UUID) {
	for id := range m.removeddeparture_flights {
		ids = append(ids, id)
	}
	return
}

// DepartureFlightsIDs returns the "departure_flights" edge IDs in the mutation.
func (m *AirportMutation) DepartureFlightsIDs() (ids []uuid.UUID) {
	for id := range m.departure_flights {
		ids = append(ids, id)
	}
	return
}

// ResetDepartureFlights resets all changes to the "departure_flights" edge.
func (m *AirportMutation) ResetDepartureFlights() {
	m.departure_flights = nil
	m.cleareddeparture_flights = false
	m.removeddeparture_flights = nil
}

// AddArrivalFlightIDs adds the "arrival_flights" edge to the Flight entity by ids.
func (m *AirportMutation) AddArrivalFlightIDs(ids ...uuid.UUID) {
	if m.arrival_flights == nil {
		m.arrival_flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.arrival_flights[ids[i]] = struct{}{}
	}
}

// ClearArrivalFlights clears the "arrival_flights" edge to the Flight entity.
func (m *AirportMutation) ClearArrivalFlights() {
	m.clearedarrival_flights = true
}

// ArrivalFlightsCleared reports if the "arrival_flights" edge to the Flight entity was cleared.
func (m *AirportMutation) ArrivalFlightsCleared() bool {
	return m.clearedarrival_flights
}

// RemoveArrivalFlightIDs removes the "arrival_flights" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveArrivalFlightIDs(ids ...uuid.UUID) {
	if m.removedarrival_flights == nil {
		m.removedarrival_flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.arrival_flights, ids[i])
		m.removedarrival_flights[ids[i]] = struct{}{}
	}
}

// RemovedArrivalFlights returns the removed IDs of the "arrival_flights" edge to the Flight entity.
func (m *AirportMutation) RemovedArrivalFlightsIDs() (ids []uuid.UUID) {
	for id := range m.removedarrival_flights {
		ids = append(ids, id)
	}
	return
}

// ArrivalFlightsIDs returns the "arrival_flights" edge IDs in the mutation.
func (m *AirportMutation) ArrivalFlightsIDs() (ids []uuid.UUID) {
	for id := range m.arrival_flights {
		ids = append(ids, id)
	}
	return
}

// ResetArrivalFlights resets all changes to the "arrival_flights" edge.
func (m *AirportMutation) ResetArrivalFlights() {
	m.arrival_flights = nil
	m.clearedarrival_flights = false
	m.removedarrival_flights = nil
}

// AddOriginIteneraryIDs adds the "origin_iteneraries" edge to the Itenerary entity by ids.
func (m *AirportMutation) AddOriginIteneraryIDs(ids ...uuid.UUID) {
	if m.origin_iteneraries == nil {
		m.origin_iteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.origin_iteneraries[ids[i]] = struct{}{}
	}
}

// ClearOriginIteneraries clears the "origin_iteneraries" edge to the Itenerary entity.
func (m *AirportMutation) ClearOriginIteneraries() {
	m.clearedorigin_iteneraries = true
}

// OriginItenerariesCleared reports if the "origin_iteneraries" edge to the Itenerary entity was cleared.
func (m *AirportMutation) OriginItenerariesCleared() bool {
	return m.clearedorigin_iteneraries
}

// RemoveOriginIteneraryIDs removes the "origin_iteneraries" edge to the Itenerary entity by IDs.
func (m *AirportMutation) RemoveOriginIteneraryIDs(ids ...uuid.UUID) {
	if m.removedorigin_iteneraries == nil {
		m.removedorigin_iteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.origin_iteneraries, ids[i])
		m.removedorigin_iteneraries[ids[i]] = struct{}{}
	}
}

// RemovedOriginIteneraries returns the removed IDs of the "origin_iteneraries" edge to the Itenerary entity.
func (m *AirportMutation) RemovedOriginItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.removedorigin_iteneraries {
		ids = append(ids, id)
	}
	return
}

// OriginItenerariesIDs returns the "origin_iteneraries" edge IDs in the mutation.
func (m *AirportMutation) OriginItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.origin_iteneraries {
		ids = append(ids, id)
	}
	return
}

// ResetOriginIteneraries resets all changes to the "origin_iteneraries" edge.
func (m *AirportMutation) ResetOriginIteneraries() {
	m.origin_iteneraries = nil
	m.clearedorigin_iteneraries = false
	m.removedorigin_iteneraries = nil
}

// AddDestinationIteneraryIDs adds the "destination_iteneraries" edge to the Itenerary entity by ids.
func (m *AirportMutation) AddDestinationIteneraryIDs(ids ...uuid.UUID) {
	if m.destination_iteneraries == nil {
		m.destination_iteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.destination_iteneraries[ids[i]] = struct{}{}
	}
}

// ClearDestinationIteneraries clears the "destination_iteneraries" edge to the Itenerary entity.
func (m *AirportMutation) ClearDestinationIteneraries() {
	m.cleareddestination_iteneraries = true
}

// DestinationItenerariesCleared reports if the "destination_iteneraries" edge to the Itenerary entity was cleared.
func (m *AirportMutation) DestinationItenerariesCleared() bool {
	return m.cleareddestination_iteneraries
}

// RemoveDestinationIteneraryIDs removes the "destination_iteneraries" edge to the Itenerary entity by IDs.
func (m *AirportMutation) RemoveDestinationIteneraryIDs(ids ...uuid.UUID) {
	if m.removeddestination_iteneraries == nil {
		m.removeddestination_iteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.destination_iteneraries, ids[i])
		m.removeddestination_iteneraries[ids[i]] = struct{}{}
	}
}

// RemovedDestinationIteneraries returns the removed IDs of the "destination_iteneraries" edge to the Itenerary entity.
func (m *AirportMutation) RemovedDestinationItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.removeddestination_iteneraries {
		ids = append(ids, id)
	}
	return
}

// DestinationItenerariesIDs returns the "destination_iteneraries" edge IDs in the mutation.
func (m *AirportMutation) DestinationItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.destination_iteneraries {
		ids = append(ids, id)
	}
	return
}

// ResetDestinationIteneraries resets all changes to the "destination_iteneraries" edge.
func (m *AirportMutation) ResetDestinationIteneraries() {
	m.destination_iteneraries = nil
	m.cleareddestination_iteneraries = false
	m.removeddestination_iteneraries = nil
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.iata_code != nil {
		fields = append(fields, airport.FieldIataCode)
	}
	if m.icao_code != nil {
		fields = append(fields, airport.FieldIcaoCode)
	}
	if m.elevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.terminals != nil {
		fields = append(fields, airport.FieldTerminals)
	}
	if m.runways != nil {
		fields = append(fields, airport.FieldRunways)
	}
	if m.created_at != nil {
		fields = append(fields, airport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, airport.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldName:
		return m.Name()
	case airport.FieldIataCode:
		return m.IataCode()
	case airport.FieldIcaoCode:
		return m.IcaoCode()
	case airport.FieldElevation:
		return m.Elevation()
	case airport.FieldTerminals:
		return m.Terminals()
	case airport.FieldRunways:
		return m.Runways()
	case airport.FieldCreatedAt:
		return m.CreatedAt()
	case airport.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldIataCode:
		return m.OldIataCode(ctx)
	case airport.FieldIcaoCode:
		return m.OldIcaoCode(ctx)
	case airport.FieldElevation:
		return m.OldElevation(ctx)
	case airport.FieldTerminals:
		return m.OldTerminals(ctx)
	case airport.FieldRunways:
		return m.OldRunways(ctx)
	case airport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case airport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldIataCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIataCode(v)
		return nil
	case airport.FieldIcaoCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcaoCode(v)
		return nil
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElevation(v)
		return nil
	case airport.FieldTerminals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminals(v)
		return nil
	case airport.FieldRunways:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunways(v)
		return nil
	case airport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case airport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addelevation != nil {
		fields = append(fields, airport.FieldElevation)
	}
	if m.addterminals != nil {
		fields = append(fields, airport.FieldTerminals)
	}
	if m.addrunways != nil {
		fields = append(fields, airport.FieldRunways)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldElevation:
		return m.AddedElevation()
	case airport.FieldTerminals:
		return m.AddedTerminals()
	case airport.FieldRunways:
		return m.AddedRunways()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldElevation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElevation(v)
		return nil
	case airport.FieldTerminals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTerminals(v)
		return nil
	case airport.FieldRunways:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunways(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldIataCode:
		m.ResetIataCode()
		return nil
	case airport.FieldIcaoCode:
		m.ResetIcaoCode()
		return nil
	case airport.FieldElevation:
		m.ResetElevation()
		return nil
	case airport.FieldTerminals:
		m.ResetTerminals()
		return nil
	case airport.FieldRunways:
		m.ResetRunways()
		return nil
	case airport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case airport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.address != nil {
		edges = append(edges, airport.EdgeAddress)
	}
	if m.front_desks != nil {
		edges = append(edges, airport.EdgeFrontDesks)
	}
	if m.departure_flights != nil {
		edges = append(edges, airport.EdgeDepartureFlights)
	}
	if m.arrival_flights != nil {
		edges = append(edges, airport.EdgeArrivalFlights)
	}
	if m.origin_iteneraries != nil {
		edges = append(edges, airport.EdgeOriginIteneraries)
	}
	if m.destination_iteneraries != nil {
		edges = append(edges, airport.EdgeDestinationIteneraries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case airport.EdgeFrontDesks:
		ids := make([]ent.Value, 0, len(m.front_desks))
		for id := range m.front_desks {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDepartureFlights:
		ids := make([]ent.Value, 0, len(m.departure_flights))
		for id := range m.departure_flights {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeArrivalFlights:
		ids := make([]ent.Value, 0, len(m.arrival_flights))
		for id := range m.arrival_flights {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeOriginIteneraries:
		ids := make([]ent.Value, 0, len(m.origin_iteneraries))
		for id := range m.origin_iteneraries {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDestinationIteneraries:
		ids := make([]ent.Value, 0, len(m.destination_iteneraries))
		for id := range m.destination_iteneraries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedfront_desks != nil {
		edges = append(edges, airport.EdgeFrontDesks)
	}
	if m.removeddeparture_flights != nil {
		edges = append(edges, airport.EdgeDepartureFlights)
	}
	if m.removedarrival_flights != nil {
		edges = append(edges, airport.EdgeArrivalFlights)
	}
	if m.removedorigin_iteneraries != nil {
		edges = append(edges, airport.EdgeOriginIteneraries)
	}
	if m.removeddestination_iteneraries != nil {
		edges = append(edges, airport.EdgeDestinationIteneraries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeFrontDesks:
		ids := make([]ent.Value, 0, len(m.removedfront_desks))
		for id := range m.removedfront_desks {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDepartureFlights:
		ids := make([]ent.Value, 0, len(m.removeddeparture_flights))
		for id := range m.removeddeparture_flights {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeArrivalFlights:
		ids := make([]ent.Value, 0, len(m.removedarrival_flights))
		for id := range m.removedarrival_flights {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeOriginIteneraries:
		ids := make([]ent.Value, 0, len(m.removedorigin_iteneraries))
		for id := range m.removedorigin_iteneraries {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDestinationIteneraries:
		ids := make([]ent.Value, 0, len(m.removeddestination_iteneraries))
		for id := range m.removeddestination_iteneraries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedaddress {
		edges = append(edges, airport.EdgeAddress)
	}
	if m.clearedfront_desks {
		edges = append(edges, airport.EdgeFrontDesks)
	}
	if m.cleareddeparture_flights {
		edges = append(edges, airport.EdgeDepartureFlights)
	}
	if m.clearedarrival_flights {
		edges = append(edges, airport.EdgeArrivalFlights)
	}
	if m.clearedorigin_iteneraries {
		edges = append(edges, airport.EdgeOriginIteneraries)
	}
	if m.cleareddestination_iteneraries {
		edges = append(edges, airport.EdgeDestinationIteneraries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeAddress:
		return m.clearedaddress
	case airport.EdgeFrontDesks:
		return m.clearedfront_desks
	case airport.EdgeDepartureFlights:
		return m.cleareddeparture_flights
	case airport.EdgeArrivalFlights:
		return m.clearedarrival_flights
	case airport.EdgeOriginIteneraries:
		return m.clearedorigin_iteneraries
	case airport.EdgeDestinationIteneraries:
		return m.cleareddestination_iteneraries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	case airport.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeAddress:
		m.ResetAddress()
		return nil
	case airport.EdgeFrontDesks:
		m.ResetFrontDesks()
		return nil
	case airport.EdgeDepartureFlights:
		m.ResetDepartureFlights()
		return nil
	case airport.EdgeArrivalFlights:
		m.ResetArrivalFlights()
		return nil
	case airport.EdgeOriginIteneraries:
		m.ResetOriginIteneraries()
		return nil
	case airport.EdgeDestinationIteneraries:
		m.ResetDestinationIteneraries()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// CrewMutation represents an operation that mutates the Crew nodes in the graph.
type CrewMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	employee_id    *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	airline        *uuid.UUID
	clearedairline bool
	flights        map[uuid.UUID]struct{}
	removedflights map[uuid.UUID]struct{}
	clearedflights bool
	done           bool
	oldValue       func(context.Context) (*Crew, error)
	predicates     []predicate.Crew
}

var _ ent.Mutation = (*CrewMutation)(nil)

// crewOption allows management of the mutation configuration using functional options.
type crewOption func(*CrewMutation)

// newCrewMutation creates new mutation for the Crew entity.
func newCrewMutation(c config, op Op, opts ...crewOption) *CrewMutation {
	m := &CrewMutation{
		config:        c,
		op:            op,
		typ:           TypeCrew,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCrewID sets the ID field of the mutation.
func withCrewID(id uuid.UUID) crewOption {
	return func(m *CrewMutation) {
		var (
			err   error
			once  sync.Once
			value *Crew
		)
		m.oldValue = func(ctx context.Context) (*Crew, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Crew.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCrew sets the old Crew of the mutation.
func withCrew(node *Crew) crewOption {
	return func(m *CrewMutation) {
		m.oldValue = func(context.Context) (*Crew, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CrewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CrewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Crew entities.
func (m *CrewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CrewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CrewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Crew.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *CrewMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *CrewMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Crew entity.
// If the Crew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CrewMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *CrewMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CrewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CrewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Crew entity.
// If the Crew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CrewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CrewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CrewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CrewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Crew entity.
// If the Crew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CrewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CrewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CrewMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CrewMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CrewMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CrewMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CrewMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CrewMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAirlineID sets the "airline" edge to the Airline entity by id.
func (m *CrewMutation) SetAirlineID(id uuid.UUID) {
	m.airline = &id
}

// ClearAirline clears the "airline" edge to the Airline entity.
func (m *CrewMutation) ClearAirline() {
	m.clearedairline = true
}

// AirlineCleared reports if the "airline" edge to the Airline entity was cleared.
func (m *CrewMutation) AirlineCleared() bool {
	return m.clearedairline
}

// AirlineID returns the "airline" edge ID in the mutation.
func (m *CrewMutation) AirlineID() (id uuid.UUID, exists bool) {
	if m.airline != nil {
		return *m.airline, true
	}
	return
}

// AirlineIDs returns the "airline" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirlineID instead. It exists only for internal usage by the builders.
func (m *CrewMutation) AirlineIDs() (ids []uuid.UUID) {
	if id := m.airline; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirline resets all changes to the "airline" edge.
func (m *CrewMutation) ResetAirline() {
	m.airline = nil
	m.clearedairline = false
}

// AddFlightIDs adds the "flights" edge to the Flight entity by ids.
func (m *CrewMutation) AddFlightIDs(ids ...uuid.UUID) {
	if m.flights == nil {
		m.flights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flights[ids[i]] = struct{}{}
	}
}

// ClearFlights clears the "flights" edge to the Flight entity.
func (m *CrewMutation) ClearFlights() {
	m.clearedflights = true
}

// FlightsCleared reports if the "flights" edge to the Flight entity was cleared.
func (m *CrewMutation) FlightsCleared() bool {
	return m.clearedflights
}

// RemoveFlightIDs removes the "flights" edge to the Flight entity by IDs.
func (m *CrewMutation) RemoveFlightIDs(ids ...uuid.UUID) {
	if m.removedflights == nil {
		m.removedflights = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flights, ids[i])
		m.removedflights[ids[i]] = struct{}{}
	}
}

// RemovedFlights returns the removed IDs of the "flights" edge to the Flight entity.
func (m *CrewMutation) RemovedFlightsIDs() (ids []uuid.UUID) {
	for id := range m.removedflights {
		ids = append(ids, id)
	}
	return
}

// FlightsIDs returns the "flights" edge IDs in the mutation.
func (m *CrewMutation) FlightsIDs() (ids []uuid.UUID) {
	for id := range m.flights {
		ids = append(ids, id)
	}
	return
}

// ResetFlights resets all changes to the "flights" edge.
func (m *CrewMutation) ResetFlights() {
	m.flights = nil
	m.clearedflights = false
	m.removedflights = nil
}

// Where appends a list predicates to the CrewMutation builder.
func (m *CrewMutation) Where(ps ...predicate.Crew) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CrewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Crew).
func (m *CrewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CrewMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employee_id != nil {
		fields = append(fields, crew.FieldEmployeeID)
	}
	if m.created_at != nil {
		fields = append(fields, crew.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, crew.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CrewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case crew.FieldEmployeeID:
		return m.EmployeeID()
	case crew.FieldCreatedAt:
		return m.CreatedAt()
	case crew.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CrewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case crew.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case crew.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case crew.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Crew field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CrewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case crew.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case crew.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case crew.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Crew field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CrewMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CrewMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CrewMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Crew numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CrewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CrewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CrewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Crew nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CrewMutation) ResetField(name string) error {
	switch name {
	case crew.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case crew.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case crew.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Crew field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CrewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, crew.EdgeUser)
	}
	if m.airline != nil {
		edges = append(edges, crew.EdgeAirline)
	}
	if m.flights != nil {
		edges = append(edges, crew.EdgeFlights)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CrewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case crew.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case crew.EdgeAirline:
		if id := m.airline; id != nil {
			return []ent.Value{*id}
		}
	case crew.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.flights))
		for id := range m.flights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CrewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedflights != nil {
		edges = append(edges, crew.EdgeFlights)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CrewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case crew.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.removedflights))
		for id := range m.removedflights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CrewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, crew.EdgeUser)
	}
	if m.clearedairline {
		edges = append(edges, crew.EdgeAirline)
	}
	if m.clearedflights {
		edges = append(edges, crew.EdgeFlights)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CrewMutation) EdgeCleared(name string) bool {
	switch name {
	case crew.EdgeUser:
		return m.cleareduser
	case crew.EdgeAirline:
		return m.clearedairline
	case crew.EdgeFlights:
		return m.clearedflights
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CrewMutation) ClearEdge(name string) error {
	switch name {
	case crew.EdgeUser:
		m.ClearUser()
		return nil
	case crew.EdgeAirline:
		m.ClearAirline()
		return nil
	}
	return fmt.Errorf("unknown Crew unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CrewMutation) ResetEdge(name string) error {
	switch name {
	case crew.EdgeUser:
		m.ResetUser()
		return nil
	case crew.EdgeAirline:
		m.ResetAirline()
		return nil
	case crew.EdgeFlights:
		m.ResetFlights()
		return nil
	}
	return fmt.Errorf("unknown Crew edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	frequent_flyer_number *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	iteneraries           map[uuid.UUID]struct{}
	removediteneraries    map[uuid.UUID]struct{}
	clearediteneraries    bool
	done                  bool
	oldValue              func(context.Context) (*Customer, error)
	predicates            []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id uuid.UUID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFrequentFlyerNumber sets the "frequent_flyer_number" field.
func (m *CustomerMutation) SetFrequentFlyerNumber(s string) {
	m.frequent_flyer_number = &s
}

// FrequentFlyerNumber returns the value of the "frequent_flyer_number" field in the mutation.
func (m *CustomerMutation) FrequentFlyerNumber() (r string, exists bool) {
	v := m.frequent_flyer_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFrequentFlyerNumber returns the old "frequent_flyer_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFrequentFlyerNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrequentFlyerNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrequentFlyerNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrequentFlyerNumber: %w", err)
	}
	return oldValue.FrequentFlyerNumber, nil
}

// ResetFrequentFlyerNumber resets all changes to the "frequent_flyer_number" field.
func (m *CustomerMutation) ResetFrequentFlyerNumber() {
	m.frequent_flyer_number = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CustomerMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CustomerMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CustomerMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CustomerMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CustomerMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddIteneraryIDs adds the "iteneraries" edge to the Itenerary entity by ids.
func (m *CustomerMutation) AddIteneraryIDs(ids ...uuid.UUID) {
	if m.iteneraries == nil {
		m.iteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.iteneraries[ids[i]] = struct{}{}
	}
}

// ClearIteneraries clears the "iteneraries" edge to the Itenerary entity.
func (m *CustomerMutation) ClearIteneraries() {
	m.clearediteneraries = true
}

// ItenerariesCleared reports if the "iteneraries" edge to the Itenerary entity was cleared.
func (m *CustomerMutation) ItenerariesCleared() bool {
	return m.clearediteneraries
}

// RemoveIteneraryIDs removes the "iteneraries" edge to the Itenerary entity by IDs.
func (m *CustomerMutation) RemoveIteneraryIDs(ids ...uuid.UUID) {
	if m.removediteneraries == nil {
		m.removediteneraries = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.iteneraries, ids[i])
		m.removediteneraries[ids[i]] = struct{}{}
	}
}

// RemovedIteneraries returns the removed IDs of the "iteneraries" edge to the Itenerary entity.
func (m *CustomerMutation) RemovedItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.removediteneraries {
		ids = append(ids, id)
	}
	return
}

// ItenerariesIDs returns the "iteneraries" edge IDs in the mutation.
func (m *CustomerMutation) ItenerariesIDs() (ids []uuid.UUID) {
	for id := range m.iteneraries {
		ids = append(ids, id)
	}
	return
}

// ResetIteneraries resets all changes to the "iteneraries" edge.
func (m *CustomerMutation) ResetIteneraries() {
	m.iteneraries = nil
	m.clearediteneraries = false
	m.removediteneraries = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.frequent_flyer_number != nil {
		fields = append(fields, customer.FieldFrequentFlyerNumber)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldFrequentFlyerNumber:
		return m.FrequentFlyerNumber()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldFrequentFlyerNumber:
		return m.OldFrequentFlyerNumber(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldFrequentFlyerNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrequentFlyerNumber(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldFrequentFlyerNumber:
		m.ResetFrequentFlyerNumber()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, customer.EdgeUser)
	}
	if m.iteneraries != nil {
		edges = append(edges, customer.EdgeIteneraries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeIteneraries:
		ids := make([]ent.Value, 0, len(m.iteneraries))
		for id := range m.iteneraries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removediteneraries != nil {
		edges = append(edges, customer.EdgeIteneraries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeIteneraries:
		ids := make([]ent.Value, 0, len(m.removediteneraries))
		for id := range m.removediteneraries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, customer.EdgeUser)
	}
	if m.clearediteneraries {
		edges = append(edges, customer.EdgeIteneraries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeUser:
		return m.cleareduser
	case customer.EdgeIteneraries:
		return m.clearediteneraries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeUser:
		m.ResetUser()
		return nil
	case customer.EdgeIteneraries:
		m.ResetIteneraries()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// FlightMutation represents an operation that mutates the Flight nodes in the graph.
type FlightMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	flight_number            *string
	duration                 *int
	addduration              *int
	distance                 *int
	adddistance              *int
	boarding_policy          *enums.BoardingPolicy
	trip_type                *enums.TripType
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	flight_instances         map[uuid.UUID]struct{}
	removedflight_instances  map[uuid.UUID]struct{}
	clearedflight_instances  bool
	flight_schedules         map[uuid.UUID]struct{}
	removedflight_schedules  map[uuid.UUID]struct{}
	clearedflight_schedules  bool
	crews                    map[uuid.UUID]struct{}
	removedcrews             map[uuid.UUID]struct{}
	clearedcrews             bool
	departure_airport        *uuid.UUID
	cleareddeparture_airport bool
	arrival_airport          *uuid.UUID
	clearedarrival_airport   bool
	airline                  *uuid.UUID
	clearedairline           bool
	done                     bool
	oldValue                 func(context.Context) (*Flight, error)
	predicates               []predicate.Flight
}

var _ ent.Mutation = (*FlightMutation)(nil)

// flightOption allows management of the mutation configuration using functional options.
type flightOption func(*FlightMutation)

// newFlightMutation creates new mutation for the Flight entity.
func newFlightMutation(c config, op Op, opts ...flightOption) *FlightMutation {
	m := &FlightMutation{
		config:        c,
		op:            op,
		typ:           TypeFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightID sets the ID field of the mutation.
func withFlightID(id uuid.UUID) flightOption {
	return func(m *FlightMutation) {
		var (
			err   error
			once  sync.Once
			value *Flight
		)
		m.oldValue = func(ctx context.Context) (*Flight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlight sets the old Flight of the mutation.
func withFlight(node *Flight) flightOption {
	return func(m *FlightMutation) {
		m.oldValue = func(context.Context) (*Flight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Flight entities.
func (m *FlightMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Flight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlightNumber sets the "flight_number" field.
func (m *FlightMutation) SetFlightNumber(s string) {
	m.flight_number = &s
}

// FlightNumber returns the value of the "flight_number" field in the mutation.
func (m *FlightMutation) FlightNumber() (r string, exists bool) {
	v := m.flight_number
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightNumber returns the old "flight_number" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldFlightNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightNumber: %w", err)
	}
	return oldValue.FlightNumber, nil
}

// ResetFlightNumber resets all changes to the "flight_number" field.
func (m *FlightMutation) ResetFlightNumber() {
	m.flight_number = nil
}

// SetDuration sets the "duration" field.
func (m *FlightMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *FlightMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *FlightMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *FlightMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *FlightMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetDistance sets the "distance" field.
func (m *FlightMutation) SetDistance(i int) {
	m.distance = &i
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *FlightMutation) Distance() (r int, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldDistance(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds i to the "distance" field.
func (m *FlightMutation) AddDistance(i int) {
	if m.adddistance != nil {
		*m.adddistance += i
	} else {
		m.adddistance = &i
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *FlightMutation) AddedDistance() (r int, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ResetDistance resets all changes to the "distance" field.
func (m *FlightMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
}

// SetBoardingPolicy sets the "boarding_policy" field.
func (m *FlightMutation) SetBoardingPolicy(ep enums.BoardingPolicy) {
	m.boarding_policy = &ep
}

// BoardingPolicy returns the value of the "boarding_policy" field in the mutation.
func (m *FlightMutation) BoardingPolicy() (r enums.BoardingPolicy, exists bool) {
	v := m.boarding_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldBoardingPolicy returns the old "boarding_policy" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldBoardingPolicy(ctx context.Context) (v enums.BoardingPolicy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoardingPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoardingPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoardingPolicy: %w", err)
	}
	return oldValue.BoardingPolicy, nil
}

// ResetBoardingPolicy resets all changes to the "boarding_policy" field.
func (m *FlightMutation) ResetBoardingPolicy() {
	m.boarding_policy = nil
}

// SetTripType sets the "trip_type" field.
func (m *FlightMutation) SetTripType(et enums.TripType) {
	m.trip_type = &et
}

// TripType returns the value of the "trip_type" field in the mutation.
func (m *FlightMutation) TripType() (r enums.TripType, exists bool) {
	v := m.trip_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTripType returns the old "trip_type" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldTripType(ctx context.Context) (v enums.TripType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTripType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTripType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTripType: %w", err)
	}
	return oldValue.TripType, nil
}

// ResetTripType resets all changes to the "trip_type" field.
func (m *FlightMutation) ResetTripType() {
	m.trip_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddFlightInstanceIDs adds the "flight_instances" edge to the FlightInstance entity by ids.
func (m *FlightMutation) AddFlightInstanceIDs(ids ...uuid.UUID) {
	if m.flight_instances == nil {
		m.flight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_instances[ids[i]] = struct{}{}
	}
}

// ClearFlightInstances clears the "flight_instances" edge to the FlightInstance entity.
func (m *FlightMutation) ClearFlightInstances() {
	m.clearedflight_instances = true
}

// FlightInstancesCleared reports if the "flight_instances" edge to the FlightInstance entity was cleared.
func (m *FlightMutation) FlightInstancesCleared() bool {
	return m.clearedflight_instances
}

// RemoveFlightInstanceIDs removes the "flight_instances" edge to the FlightInstance entity by IDs.
func (m *FlightMutation) RemoveFlightInstanceIDs(ids ...uuid.UUID) {
	if m.removedflight_instances == nil {
		m.removedflight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_instances, ids[i])
		m.removedflight_instances[ids[i]] = struct{}{}
	}
}

// RemovedFlightInstances returns the removed IDs of the "flight_instances" edge to the FlightInstance entity.
func (m *FlightMutation) RemovedFlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_instances {
		ids = append(ids, id)
	}
	return
}

// FlightInstancesIDs returns the "flight_instances" edge IDs in the mutation.
func (m *FlightMutation) FlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.flight_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFlightInstances resets all changes to the "flight_instances" edge.
func (m *FlightMutation) ResetFlightInstances() {
	m.flight_instances = nil
	m.clearedflight_instances = false
	m.removedflight_instances = nil
}

// AddFlightScheduleIDs adds the "flight_schedules" edge to the FlightSchedule entity by ids.
func (m *FlightMutation) AddFlightScheduleIDs(ids ...uuid.UUID) {
	if m.flight_schedules == nil {
		m.flight_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_schedules[ids[i]] = struct{}{}
	}
}

// ClearFlightSchedules clears the "flight_schedules" edge to the FlightSchedule entity.
func (m *FlightMutation) ClearFlightSchedules() {
	m.clearedflight_schedules = true
}

// FlightSchedulesCleared reports if the "flight_schedules" edge to the FlightSchedule entity was cleared.
func (m *FlightMutation) FlightSchedulesCleared() bool {
	return m.clearedflight_schedules
}

// RemoveFlightScheduleIDs removes the "flight_schedules" edge to the FlightSchedule entity by IDs.
func (m *FlightMutation) RemoveFlightScheduleIDs(ids ...uuid.UUID) {
	if m.removedflight_schedules == nil {
		m.removedflight_schedules = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_schedules, ids[i])
		m.removedflight_schedules[ids[i]] = struct{}{}
	}
}

// RemovedFlightSchedules returns the removed IDs of the "flight_schedules" edge to the FlightSchedule entity.
func (m *FlightMutation) RemovedFlightSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_schedules {
		ids = append(ids, id)
	}
	return
}

// FlightSchedulesIDs returns the "flight_schedules" edge IDs in the mutation.
func (m *FlightMutation) FlightSchedulesIDs() (ids []uuid.UUID) {
	for id := range m.flight_schedules {
		ids = append(ids, id)
	}
	return
}

// ResetFlightSchedules resets all changes to the "flight_schedules" edge.
func (m *FlightMutation) ResetFlightSchedules() {
	m.flight_schedules = nil
	m.clearedflight_schedules = false
	m.removedflight_schedules = nil
}

// AddCrewIDs adds the "crews" edge to the Crew entity by ids.
func (m *FlightMutation) AddCrewIDs(ids ...uuid.UUID) {
	if m.crews == nil {
		m.crews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.crews[ids[i]] = struct{}{}
	}
}

// ClearCrews clears the "crews" edge to the Crew entity.
func (m *FlightMutation) ClearCrews() {
	m.clearedcrews = true
}

// CrewsCleared reports if the "crews" edge to the Crew entity was cleared.
func (m *FlightMutation) CrewsCleared() bool {
	return m.clearedcrews
}

// RemoveCrewIDs removes the "crews" edge to the Crew entity by IDs.
func (m *FlightMutation) RemoveCrewIDs(ids ...uuid.UUID) {
	if m.removedcrews == nil {
		m.removedcrews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.crews, ids[i])
		m.removedcrews[ids[i]] = struct{}{}
	}
}

// RemovedCrews returns the removed IDs of the "crews" edge to the Crew entity.
func (m *FlightMutation) RemovedCrewsIDs() (ids []uuid.UUID) {
	for id := range m.removedcrews {
		ids = append(ids, id)
	}
	return
}

// CrewsIDs returns the "crews" edge IDs in the mutation.
func (m *FlightMutation) CrewsIDs() (ids []uuid.UUID) {
	for id := range m.crews {
		ids = append(ids, id)
	}
	return
}

// ResetCrews resets all changes to the "crews" edge.
func (m *FlightMutation) ResetCrews() {
	m.crews = nil
	m.clearedcrews = false
	m.removedcrews = nil
}

// SetDepartureAirportID sets the "departure_airport" edge to the Airport entity by id.
func (m *FlightMutation) SetDepartureAirportID(id uuid.UUID) {
	m.departure_airport = &id
}

// ClearDepartureAirport clears the "departure_airport" edge to the Airport entity.
func (m *FlightMutation) ClearDepartureAirport() {
	m.cleareddeparture_airport = true
}

// DepartureAirportCleared reports if the "departure_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) DepartureAirportCleared() bool {
	return m.cleareddeparture_airport
}

// DepartureAirportID returns the "departure_airport" edge ID in the mutation.
func (m *FlightMutation) DepartureAirportID() (id uuid.UUID, exists bool) {
	if m.departure_airport != nil {
		return *m.departure_airport, true
	}
	return
}

// DepartureAirportIDs returns the "departure_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartureAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) DepartureAirportIDs() (ids []uuid.UUID) {
	if id := m.departure_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartureAirport resets all changes to the "departure_airport" edge.
func (m *FlightMutation) ResetDepartureAirport() {
	m.departure_airport = nil
	m.cleareddeparture_airport = false
}

// SetArrivalAirportID sets the "arrival_airport" edge to the Airport entity by id.
func (m *FlightMutation) SetArrivalAirportID(id uuid.UUID) {
	m.arrival_airport = &id
}

// ClearArrivalAirport clears the "arrival_airport" edge to the Airport entity.
func (m *FlightMutation) ClearArrivalAirport() {
	m.clearedarrival_airport = true
}

// ArrivalAirportCleared reports if the "arrival_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) ArrivalAirportCleared() bool {
	return m.clearedarrival_airport
}

// ArrivalAirportID returns the "arrival_airport" edge ID in the mutation.
func (m *FlightMutation) ArrivalAirportID() (id uuid.UUID, exists bool) {
	if m.arrival_airport != nil {
		return *m.arrival_airport, true
	}
	return
}

// ArrivalAirportIDs returns the "arrival_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArrivalAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) ArrivalAirportIDs() (ids []uuid.UUID) {
	if id := m.arrival_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArrivalAirport resets all changes to the "arrival_airport" edge.
func (m *FlightMutation) ResetArrivalAirport() {
	m.arrival_airport = nil
	m.clearedarrival_airport = false
}

// SetAirlineID sets the "airline" edge to the Airline entity by id.
func (m *FlightMutation) SetAirlineID(id uuid.UUID) {
	m.airline = &id
}

// ClearAirline clears the "airline" edge to the Airline entity.
func (m *FlightMutation) ClearAirline() {
	m.clearedairline = true
}

// AirlineCleared reports if the "airline" edge to the Airline entity was cleared.
func (m *FlightMutation) AirlineCleared() bool {
	return m.clearedairline
}

// AirlineID returns the "airline" edge ID in the mutation.
func (m *FlightMutation) AirlineID() (id uuid.UUID, exists bool) {
	if m.airline != nil {
		return *m.airline, true
	}
	return
}

// AirlineIDs returns the "airline" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirlineID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) AirlineIDs() (ids []uuid.UUID) {
	if id := m.airline; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirline resets all changes to the "airline" edge.
func (m *FlightMutation) ResetAirline() {
	m.airline = nil
	m.clearedairline = false
}

// Where appends a list predicates to the FlightMutation builder.
func (m *FlightMutation) Where(ps ...predicate.Flight) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlightMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Flight).
func (m *FlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.flight_number != nil {
		fields = append(fields, flight.FieldFlightNumber)
	}
	if m.duration != nil {
		fields = append(fields, flight.FieldDuration)
	}
	if m.distance != nil {
		fields = append(fields, flight.FieldDistance)
	}
	if m.boarding_policy != nil {
		fields = append(fields, flight.FieldBoardingPolicy)
	}
	if m.trip_type != nil {
		fields = append(fields, flight.FieldTripType)
	}
	if m.created_at != nil {
		fields = append(fields, flight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flight.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldFlightNumber:
		return m.FlightNumber()
	case flight.FieldDuration:
		return m.Duration()
	case flight.FieldDistance:
		return m.Distance()
	case flight.FieldBoardingPolicy:
		return m.BoardingPolicy()
	case flight.FieldTripType:
		return m.TripType()
	case flight.FieldCreatedAt:
		return m.CreatedAt()
	case flight.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flight.FieldFlightNumber:
		return m.OldFlightNumber(ctx)
	case flight.FieldDuration:
		return m.OldDuration(ctx)
	case flight.FieldDistance:
		return m.OldDistance(ctx)
	case flight.FieldBoardingPolicy:
		return m.OldBoardingPolicy(ctx)
	case flight.FieldTripType:
		return m.OldTripType(ctx)
	case flight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Flight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flight.FieldFlightNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightNumber(v)
		return nil
	case flight.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case flight.FieldDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	case flight.FieldBoardingPolicy:
		v, ok := value.(enums.BoardingPolicy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoardingPolicy(v)
		return nil
	case flight.FieldTripType:
		v, ok := value.(enums.TripType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTripType(v)
		return nil
	case flight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, flight.FieldDuration)
	}
	if m.adddistance != nil {
		fields = append(fields, flight.FieldDistance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldDuration:
		return m.AddedDuration()
	case flight.FieldDistance:
		return m.AddedDistance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flight.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case flight.FieldDistance:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Flight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Flight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightMutation) ResetField(name string) error {
	switch name {
	case flight.FieldFlightNumber:
		m.ResetFlightNumber()
		return nil
	case flight.FieldDuration:
		m.ResetDuration()
		return nil
	case flight.FieldDistance:
		m.ResetDistance()
		return nil
	case flight.FieldBoardingPolicy:
		m.ResetBoardingPolicy()
		return nil
	case flight.FieldTripType:
		m.ResetTripType()
		return nil
	case flight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.flight_instances != nil {
		edges = append(edges, flight.EdgeFlightInstances)
	}
	if m.flight_schedules != nil {
		edges = append(edges, flight.EdgeFlightSchedules)
	}
	if m.crews != nil {
		edges = append(edges, flight.EdgeCrews)
	}
	if m.departure_airport != nil {
		edges = append(edges, flight.EdgeDepartureAirport)
	}
	if m.arrival_airport != nil {
		edges = append(edges, flight.EdgeArrivalAirport)
	}
	if m.airline != nil {
		edges = append(edges, flight.EdgeAirline)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.flight_instances))
		for id := range m.flight_instances {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeFlightSchedules:
		ids := make([]ent.Value, 0, len(m.flight_schedules))
		for id := range m.flight_schedules {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeCrews:
		ids := make([]ent.Value, 0, len(m.crews))
		for id := range m.crews {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeDepartureAirport:
		if id := m.departure_airport; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeArrivalAirport:
		if id := m.arrival_airport; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeAirline:
		if id := m.airline; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedflight_instances != nil {
		edges = append(edges, flight.EdgeFlightInstances)
	}
	if m.removedflight_schedules != nil {
		edges = append(edges, flight.EdgeFlightSchedules)
	}
	if m.removedcrews != nil {
		edges = append(edges, flight.EdgeCrews)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.removedflight_instances))
		for id := range m.removedflight_instances {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeFlightSchedules:
		ids := make([]ent.Value, 0, len(m.removedflight_schedules))
		for id := range m.removedflight_schedules {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeCrews:
		ids := make([]ent.Value, 0, len(m.removedcrews))
		for id := range m.removedcrews {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedflight_instances {
		edges = append(edges, flight.EdgeFlightInstances)
	}
	if m.clearedflight_schedules {
		edges = append(edges, flight.EdgeFlightSchedules)
	}
	if m.clearedcrews {
		edges = append(edges, flight.EdgeCrews)
	}
	if m.cleareddeparture_airport {
		edges = append(edges, flight.EdgeDepartureAirport)
	}
	if m.clearedarrival_airport {
		edges = append(edges, flight.EdgeArrivalAirport)
	}
	if m.clearedairline {
		edges = append(edges, flight.EdgeAirline)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightMutation) EdgeCleared(name string) bool {
	switch name {
	case flight.EdgeFlightInstances:
		return m.clearedflight_instances
	case flight.EdgeFlightSchedules:
		return m.clearedflight_schedules
	case flight.EdgeCrews:
		return m.clearedcrews
	case flight.EdgeDepartureAirport:
		return m.cleareddeparture_airport
	case flight.EdgeArrivalAirport:
		return m.clearedarrival_airport
	case flight.EdgeAirline:
		return m.clearedairline
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightMutation) ClearEdge(name string) error {
	switch name {
	case flight.EdgeDepartureAirport:
		m.ClearDepartureAirport()
		return nil
	case flight.EdgeArrivalAirport:
		m.ClearArrivalAirport()
		return nil
	case flight.EdgeAirline:
		m.ClearAirline()
		return nil
	}
	return fmt.Errorf("unknown Flight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightMutation) ResetEdge(name string) error {
	switch name {
	case flight.EdgeFlightInstances:
		m.ResetFlightInstances()
		return nil
	case flight.EdgeFlightSchedules:
		m.ResetFlightSchedules()
		return nil
	case flight.EdgeCrews:
		m.ResetCrews()
		return nil
	case flight.EdgeDepartureAirport:
		m.ResetDepartureAirport()
		return nil
	case flight.EdgeArrivalAirport:
		m.ResetArrivalAirport()
		return nil
	case flight.EdgeAirline:
		m.ResetAirline()
		return nil
	}
	return fmt.Errorf("unknown Flight edge %s", name)
}

// FlightInstanceMutation represents an operation that mutates the FlightInstance nodes in the graph.
type FlightInstanceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	departure_date             *customtypes.Date
	arrival_date               *customtypes.Date
	departure_gate             *int
	adddeparture_gate          *int
	arrival_gate               *int
	addarrival_gate            *int
	flight_status              *enums.FlightStatus
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	flight                     *uuid.UUID
	clearedflight              bool
	flight_schedule            *uuid.UUID
	clearedflight_schedule     bool
	aircraft                   *uuid.UUID
	clearedaircraft            bool
	flight_reservations        map[uuid.UUID]struct{}
	removedflight_reservations map[uuid.UUID]struct{}
	clearedflight_reservations bool
	flight_seats               map[uuid.UUID]struct{}
	removedflight_seats        map[uuid.UUID]struct{}
	clearedflight_seats        bool
	done                       bool
	oldValue                   func(context.Context) (*FlightInstance, error)
	predicates                 []predicate.FlightInstance
}

var _ ent.Mutation = (*FlightInstanceMutation)(nil)

// flightinstanceOption allows management of the mutation configuration using functional options.
type flightinstanceOption func(*FlightInstanceMutation)

// newFlightInstanceMutation creates new mutation for the FlightInstance entity.
func newFlightInstanceMutation(c config, op Op, opts ...flightinstanceOption) *FlightInstanceMutation {
	m := &FlightInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeFlightInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightInstanceID sets the ID field of the mutation.
func withFlightInstanceID(id uuid.UUID) flightinstanceOption {
	return func(m *FlightInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *FlightInstance
		)
		m.oldValue = func(ctx context.Context) (*FlightInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlightInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlightInstance sets the old FlightInstance of the mutation.
func withFlightInstance(node *FlightInstance) flightinstanceOption {
	return func(m *FlightInstanceMutation) {
		m.oldValue = func(context.Context) (*FlightInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlightInstance entities.
func (m *FlightInstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightInstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightInstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlightInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDepartureDate sets the "departure_date" field.
func (m *FlightInstanceMutation) SetDepartureDate(c customtypes.Date) {
	m.departure_date = &c
}

// DepartureDate returns the value of the "departure_date" field in the mutation.
func (m *FlightInstanceMutation) DepartureDate() (r customtypes.Date, exists bool) {
	v := m.departure_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureDate returns the old "departure_date" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldDepartureDate(ctx context.Context) (v customtypes.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureDate: %w", err)
	}
	return oldValue.DepartureDate, nil
}

// ResetDepartureDate resets all changes to the "departure_date" field.
func (m *FlightInstanceMutation) ResetDepartureDate() {
	m.departure_date = nil
}

// SetArrivalDate sets the "arrival_date" field.
func (m *FlightInstanceMutation) SetArrivalDate(c customtypes.Date) {
	m.arrival_date = &c
}

// ArrivalDate returns the value of the "arrival_date" field in the mutation.
func (m *FlightInstanceMutation) ArrivalDate() (r customtypes.Date, exists bool) {
	v := m.arrival_date
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalDate returns the old "arrival_date" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldArrivalDate(ctx context.Context) (v customtypes.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalDate: %w", err)
	}
	return oldValue.ArrivalDate, nil
}

// ResetArrivalDate resets all changes to the "arrival_date" field.
func (m *FlightInstanceMutation) ResetArrivalDate() {
	m.arrival_date = nil
}

// SetDepartureGate sets the "departure_gate" field.
func (m *FlightInstanceMutation) SetDepartureGate(i int) {
	m.departure_gate = &i
	m.adddeparture_gate = nil
}

// DepartureGate returns the value of the "departure_gate" field in the mutation.
func (m *FlightInstanceMutation) DepartureGate() (r int, exists bool) {
	v := m.departure_gate
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureGate returns the old "departure_gate" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldDepartureGate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureGate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureGate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureGate: %w", err)
	}
	return oldValue.DepartureGate, nil
}

// AddDepartureGate adds i to the "departure_gate" field.
func (m *FlightInstanceMutation) AddDepartureGate(i int) {
	if m.adddeparture_gate != nil {
		*m.adddeparture_gate += i
	} else {
		m.adddeparture_gate = &i
	}
}

// AddedDepartureGate returns the value that was added to the "departure_gate" field in this mutation.
func (m *FlightInstanceMutation) AddedDepartureGate() (r int, exists bool) {
	v := m.adddeparture_gate
	if v == nil {
		return
	}
	return *v, true
}

// ResetDepartureGate resets all changes to the "departure_gate" field.
func (m *FlightInstanceMutation) ResetDepartureGate() {
	m.departure_gate = nil
	m.adddeparture_gate = nil
}

// SetArrivalGate sets the "arrival_gate" field.
func (m *FlightInstanceMutation) SetArrivalGate(i int) {
	m.arrival_gate = &i
	m.addarrival_gate = nil
}

// ArrivalGate returns the value of the "arrival_gate" field in the mutation.
func (m *FlightInstanceMutation) ArrivalGate() (r int, exists bool) {
	v := m.arrival_gate
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalGate returns the old "arrival_gate" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldArrivalGate(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalGate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalGate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalGate: %w", err)
	}
	return oldValue.ArrivalGate, nil
}

// AddArrivalGate adds i to the "arrival_gate" field.
func (m *FlightInstanceMutation) AddArrivalGate(i int) {
	if m.addarrival_gate != nil {
		*m.addarrival_gate += i
	} else {
		m.addarrival_gate = &i
	}
}

// AddedArrivalGate returns the value that was added to the "arrival_gate" field in this mutation.
func (m *FlightInstanceMutation) AddedArrivalGate() (r int, exists bool) {
	v := m.addarrival_gate
	if v == nil {
		return
	}
	return *v, true
}

// ResetArrivalGate resets all changes to the "arrival_gate" field.
func (m *FlightInstanceMutation) ResetArrivalGate() {
	m.arrival_gate = nil
	m.addarrival_gate = nil
}

// SetFlightStatus sets the "flight_status" field.
func (m *FlightInstanceMutation) SetFlightStatus(es enums.FlightStatus) {
	m.flight_status = &es
}

// FlightStatus returns the value of the "flight_status" field in the mutation.
func (m *FlightInstanceMutation) FlightStatus() (r enums.FlightStatus, exists bool) {
	v := m.flight_status
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightStatus returns the old "flight_status" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldFlightStatus(ctx context.Context) (v enums.FlightStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightStatus: %w", err)
	}
	return oldValue.FlightStatus, nil
}

// ResetFlightStatus resets all changes to the "flight_status" field.
func (m *FlightInstanceMutation) ResetFlightStatus() {
	m.flight_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlightInstance entity.
// If the FlightInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFlightID sets the "flight" edge to the Flight entity by id.
func (m *FlightInstanceMutation) SetFlightID(id uuid.UUID) {
	m.flight = &id
}

// ClearFlight clears the "flight" edge to the Flight entity.
func (m *FlightInstanceMutation) ClearFlight() {
	m.clearedflight = true
}

// FlightCleared reports if the "flight" edge to the Flight entity was cleared.
func (m *FlightInstanceMutation) FlightCleared() bool {
	return m.clearedflight
}

// FlightID returns the "flight" edge ID in the mutation.
func (m *FlightInstanceMutation) FlightID() (id uuid.UUID, exists bool) {
	if m.flight != nil {
		return *m.flight, true
	}
	return
}

// FlightIDs returns the "flight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightID instead. It exists only for internal usage by the builders.
func (m *FlightInstanceMutation) FlightIDs() (ids []uuid.UUID) {
	if id := m.flight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlight resets all changes to the "flight" edge.
func (m *FlightInstanceMutation) ResetFlight() {
	m.flight = nil
	m.clearedflight = false
}

// SetFlightScheduleID sets the "flight_schedule" edge to the FlightSchedule entity by id.
func (m *FlightInstanceMutation) SetFlightScheduleID(id uuid.UUID) {
	m.flight_schedule = &id
}

// ClearFlightSchedule clears the "flight_schedule" edge to the FlightSchedule entity.
func (m *FlightInstanceMutation) ClearFlightSchedule() {
	m.clearedflight_schedule = true
}

// FlightScheduleCleared reports if the "flight_schedule" edge to the FlightSchedule entity was cleared.
func (m *FlightInstanceMutation) FlightScheduleCleared() bool {
	return m.clearedflight_schedule
}

// FlightScheduleID returns the "flight_schedule" edge ID in the mutation.
func (m *FlightInstanceMutation) FlightScheduleID() (id uuid.UUID, exists bool) {
	if m.flight_schedule != nil {
		return *m.flight_schedule, true
	}
	return
}

// FlightScheduleIDs returns the "flight_schedule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightScheduleID instead. It exists only for internal usage by the builders.
func (m *FlightInstanceMutation) FlightScheduleIDs() (ids []uuid.UUID) {
	if id := m.flight_schedule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightSchedule resets all changes to the "flight_schedule" edge.
func (m *FlightInstanceMutation) ResetFlightSchedule() {
	m.flight_schedule = nil
	m.clearedflight_schedule = false
}

// SetAircraftID sets the "aircraft" edge to the Aircraft entity by id.
func (m *FlightInstanceMutation) SetAircraftID(id uuid.UUID) {
	m.aircraft = &id
}

// ClearAircraft clears the "aircraft" edge to the Aircraft entity.
func (m *FlightInstanceMutation) ClearAircraft() {
	m.clearedaircraft = true
}

// AircraftCleared reports if the "aircraft" edge to the Aircraft entity was cleared.
func (m *FlightInstanceMutation) AircraftCleared() bool {
	return m.clearedaircraft
}

// AircraftID returns the "aircraft" edge ID in the mutation.
func (m *FlightInstanceMutation) AircraftID() (id uuid.UUID, exists bool) {
	if m.aircraft != nil {
		return *m.aircraft, true
	}
	return
}

// AircraftIDs returns the "aircraft" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AircraftID instead. It exists only for internal usage by the builders.
func (m *FlightInstanceMutation) AircraftIDs() (ids []uuid.UUID) {
	if id := m.aircraft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAircraft resets all changes to the "aircraft" edge.
func (m *FlightInstanceMutation) ResetAircraft() {
	m.aircraft = nil
	m.clearedaircraft = false
}

// AddFlightReservationIDs adds the "flight_reservations" edge to the FlightReservation entity by ids.
func (m *FlightInstanceMutation) AddFlightReservationIDs(ids ...uuid.UUID) {
	if m.flight_reservations == nil {
		m.flight_reservations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_reservations[ids[i]] = struct{}{}
	}
}

// ClearFlightReservations clears the "flight_reservations" edge to the FlightReservation entity.
func (m *FlightInstanceMutation) ClearFlightReservations() {
	m.clearedflight_reservations = true
}

// FlightReservationsCleared reports if the "flight_reservations" edge to the FlightReservation entity was cleared.
func (m *FlightInstanceMutation) FlightReservationsCleared() bool {
	return m.clearedflight_reservations
}

// RemoveFlightReservationIDs removes the "flight_reservations" edge to the FlightReservation entity by IDs.
func (m *FlightInstanceMutation) RemoveFlightReservationIDs(ids ...uuid.UUID) {
	if m.removedflight_reservations == nil {
		m.removedflight_reservations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_reservations, ids[i])
		m.removedflight_reservations[ids[i]] = struct{}{}
	}
}

// RemovedFlightReservations returns the removed IDs of the "flight_reservations" edge to the FlightReservation entity.
func (m *FlightInstanceMutation) RemovedFlightReservationsIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_reservations {
		ids = append(ids, id)
	}
	return
}

// FlightReservationsIDs returns the "flight_reservations" edge IDs in the mutation.
func (m *FlightInstanceMutation) FlightReservationsIDs() (ids []uuid.UUID) {
	for id := range m.flight_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetFlightReservations resets all changes to the "flight_reservations" edge.
func (m *FlightInstanceMutation) ResetFlightReservations() {
	m.flight_reservations = nil
	m.clearedflight_reservations = false
	m.removedflight_reservations = nil
}

// AddFlightSeatIDs adds the "flight_seats" edge to the FlightSeat entity by ids.
func (m *FlightInstanceMutation) AddFlightSeatIDs(ids ...uuid.UUID) {
	if m.flight_seats == nil {
		m.flight_seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_seats[ids[i]] = struct{}{}
	}
}

// ClearFlightSeats clears the "flight_seats" edge to the FlightSeat entity.
func (m *FlightInstanceMutation) ClearFlightSeats() {
	m.clearedflight_seats = true
}

// FlightSeatsCleared reports if the "flight_seats" edge to the FlightSeat entity was cleared.
func (m *FlightInstanceMutation) FlightSeatsCleared() bool {
	return m.clearedflight_seats
}

// RemoveFlightSeatIDs removes the "flight_seats" edge to the FlightSeat entity by IDs.
func (m *FlightInstanceMutation) RemoveFlightSeatIDs(ids ...uuid.UUID) {
	if m.removedflight_seats == nil {
		m.removedflight_seats = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_seats, ids[i])
		m.removedflight_seats[ids[i]] = struct{}{}
	}
}

// RemovedFlightSeats returns the removed IDs of the "flight_seats" edge to the FlightSeat entity.
func (m *FlightInstanceMutation) RemovedFlightSeatsIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_seats {
		ids = append(ids, id)
	}
	return
}

// FlightSeatsIDs returns the "flight_seats" edge IDs in the mutation.
func (m *FlightInstanceMutation) FlightSeatsIDs() (ids []uuid.UUID) {
	for id := range m.flight_seats {
		ids = append(ids, id)
	}
	return
}

// ResetFlightSeats resets all changes to the "flight_seats" edge.
func (m *FlightInstanceMutation) ResetFlightSeats() {
	m.flight_seats = nil
	m.clearedflight_seats = false
	m.removedflight_seats = nil
}

// Where appends a list predicates to the FlightInstanceMutation builder.
func (m *FlightInstanceMutation) Where(ps ...predicate.FlightInstance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlightInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlightInstance).
func (m *FlightInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightInstanceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.departure_date != nil {
		fields = append(fields, flightinstance.FieldDepartureDate)
	}
	if m.arrival_date != nil {
		fields = append(fields, flightinstance.FieldArrivalDate)
	}
	if m.departure_gate != nil {
		fields = append(fields, flightinstance.FieldDepartureGate)
	}
	if m.arrival_gate != nil {
		fields = append(fields, flightinstance.FieldArrivalGate)
	}
	if m.flight_status != nil {
		fields = append(fields, flightinstance.FieldFlightStatus)
	}
	if m.created_at != nil {
		fields = append(fields, flightinstance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flightinstance.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flightinstance.FieldDepartureDate:
		return m.DepartureDate()
	case flightinstance.FieldArrivalDate:
		return m.ArrivalDate()
	case flightinstance.FieldDepartureGate:
		return m.DepartureGate()
	case flightinstance.FieldArrivalGate:
		return m.ArrivalGate()
	case flightinstance.FieldFlightStatus:
		return m.FlightStatus()
	case flightinstance.FieldCreatedAt:
		return m.CreatedAt()
	case flightinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flightinstance.FieldDepartureDate:
		return m.OldDepartureDate(ctx)
	case flightinstance.FieldArrivalDate:
		return m.OldArrivalDate(ctx)
	case flightinstance.FieldDepartureGate:
		return m.OldDepartureGate(ctx)
	case flightinstance.FieldArrivalGate:
		return m.OldArrivalGate(ctx)
	case flightinstance.FieldFlightStatus:
		return m.OldFlightStatus(ctx)
	case flightinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flightinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FlightInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flightinstance.FieldDepartureDate:
		v, ok := value.(customtypes.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureDate(v)
		return nil
	case flightinstance.FieldArrivalDate:
		v, ok := value.(customtypes.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalDate(v)
		return nil
	case flightinstance.FieldDepartureGate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureGate(v)
		return nil
	case flightinstance.FieldArrivalGate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalGate(v)
		return nil
	case flightinstance.FieldFlightStatus:
		v, ok := value.(enums.FlightStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightStatus(v)
		return nil
	case flightinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flightinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FlightInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightInstanceMutation) AddedFields() []string {
	var fields []string
	if m.adddeparture_gate != nil {
		fields = append(fields, flightinstance.FieldDepartureGate)
	}
	if m.addarrival_gate != nil {
		fields = append(fields, flightinstance.FieldArrivalGate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flightinstance.FieldDepartureGate:
		return m.AddedDepartureGate()
	case flightinstance.FieldArrivalGate:
		return m.AddedArrivalGate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flightinstance.FieldDepartureGate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartureGate(v)
		return nil
	case flightinstance.FieldArrivalGate:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArrivalGate(v)
		return nil
	}
	return fmt.Errorf("unknown FlightInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlightInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightInstanceMutation) ResetField(name string) error {
	switch name {
	case flightinstance.FieldDepartureDate:
		m.ResetDepartureDate()
		return nil
	case flightinstance.FieldArrivalDate:
		m.ResetArrivalDate()
		return nil
	case flightinstance.FieldDepartureGate:
		m.ResetDepartureGate()
		return nil
	case flightinstance.FieldArrivalGate:
		m.ResetArrivalGate()
		return nil
	case flightinstance.FieldFlightStatus:
		m.ResetFlightStatus()
		return nil
	case flightinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flightinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FlightInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.flight != nil {
		edges = append(edges, flightinstance.EdgeFlight)
	}
	if m.flight_schedule != nil {
		edges = append(edges, flightinstance.EdgeFlightSchedule)
	}
	if m.aircraft != nil {
		edges = append(edges, flightinstance.EdgeAircraft)
	}
	if m.flight_reservations != nil {
		edges = append(edges, flightinstance.EdgeFlightReservations)
	}
	if m.flight_seats != nil {
		edges = append(edges, flightinstance.EdgeFlightSeats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flightinstance.EdgeFlight:
		if id := m.flight; id != nil {
			return []ent.Value{*id}
		}
	case flightinstance.EdgeFlightSchedule:
		if id := m.flight_schedule; id != nil {
			return []ent.Value{*id}
		}
	case flightinstance.EdgeAircraft:
		if id := m.aircraft; id != nil {
			return []ent.Value{*id}
		}
	case flightinstance.EdgeFlightReservations:
		ids := make([]ent.Value, 0, len(m.flight_reservations))
		for id := range m.flight_reservations {
			ids = append(ids, id)
		}
		return ids
	case flightinstance.EdgeFlightSeats:
		ids := make([]ent.Value, 0, len(m.flight_seats))
		for id := range m.flight_seats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedflight_reservations != nil {
		edges = append(edges, flightinstance.EdgeFlightReservations)
	}
	if m.removedflight_seats != nil {
		edges = append(edges, flightinstance.EdgeFlightSeats)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flightinstance.EdgeFlightReservations:
		ids := make([]ent.Value, 0, len(m.removedflight_reservations))
		for id := range m.removedflight_reservations {
			ids = append(ids, id)
		}
		return ids
	case flightinstance.EdgeFlightSeats:
		ids := make([]ent.Value, 0, len(m.removedflight_seats))
		for id := range m.removedflight_seats {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedflight {
		edges = append(edges, flightinstance.EdgeFlight)
	}
	if m.clearedflight_schedule {
		edges = append(edges, flightinstance.EdgeFlightSchedule)
	}
	if m.clearedaircraft {
		edges = append(edges, flightinstance.EdgeAircraft)
	}
	if m.clearedflight_reservations {
		edges = append(edges, flightinstance.EdgeFlightReservations)
	}
	if m.clearedflight_seats {
		edges = append(edges, flightinstance.EdgeFlightSeats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case flightinstance.EdgeFlight:
		return m.clearedflight
	case flightinstance.EdgeFlightSchedule:
		return m.clearedflight_schedule
	case flightinstance.EdgeAircraft:
		return m.clearedaircraft
	case flightinstance.EdgeFlightReservations:
		return m.clearedflight_reservations
	case flightinstance.EdgeFlightSeats:
		return m.clearedflight_seats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightInstanceMutation) ClearEdge(name string) error {
	switch name {
	case flightinstance.EdgeFlight:
		m.ClearFlight()
		return nil
	case flightinstance.EdgeFlightSchedule:
		m.ClearFlightSchedule()
		return nil
	case flightinstance.EdgeAircraft:
		m.ClearAircraft()
		return nil
	}
	return fmt.Errorf("unknown FlightInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightInstanceMutation) ResetEdge(name string) error {
	switch name {
	case flightinstance.EdgeFlight:
		m.ResetFlight()
		return nil
	case flightinstance.EdgeFlightSchedule:
		m.ResetFlightSchedule()
		return nil
	case flightinstance.EdgeAircraft:
		m.ResetAircraft()
		return nil
	case flightinstance.EdgeFlightReservations:
		m.ResetFlightReservations()
		return nil
	case flightinstance.EdgeFlightSeats:
		m.ResetFlightSeats()
		return nil
	}
	return fmt.Errorf("unknown FlightInstance edge %s", name)
}

// FlightReservationMutation represents an operation that mutates the FlightReservation nodes in the graph.
type FlightReservationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	reservation_number     *string
	reservation_status     *enums.ReservationStatus
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	flight_instance        *uuid.UUID
	clearedflight_instance bool
	itenerary              *uuid.UUID
	cleareditenerary       bool
	passengers             map[uuid.UUID]struct{}
	removedpassengers      map[uuid.UUID]struct{}
	clearedpassengers      bool
	done                   bool
	oldValue               func(context.Context) (*FlightReservation, error)
	predicates             []predicate.FlightReservation
}

var _ ent.Mutation = (*FlightReservationMutation)(nil)

// flightreservationOption allows management of the mutation configuration using functional options.
type flightreservationOption func(*FlightReservationMutation)

// newFlightReservationMutation creates new mutation for the FlightReservation entity.
func newFlightReservationMutation(c config, op Op, opts ...flightreservationOption) *FlightReservationMutation {
	m := &FlightReservationMutation{
		config:        c,
		op:            op,
		typ:           TypeFlightReservation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightReservationID sets the ID field of the mutation.
func withFlightReservationID(id uuid.UUID) flightreservationOption {
	return func(m *FlightReservationMutation) {
		var (
			err   error
			once  sync.Once
			value *FlightReservation
		)
		m.oldValue = func(ctx context.Context) (*FlightReservation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlightReservation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlightReservation sets the old FlightReservation of the mutation.
func withFlightReservation(node *FlightReservation) flightreservationOption {
	return func(m *FlightReservationMutation) {
		m.oldValue = func(context.Context) (*FlightReservation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightReservationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightReservationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlightReservation entities.
func (m *FlightReservationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightReservationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightReservationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlightReservation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReservationNumber sets the "reservation_number" field.
func (m *FlightReservationMutation) SetReservationNumber(s string) {
	m.reservation_number = &s
}

// ReservationNumber returns the value of the "reservation_number" field in the mutation.
func (m *FlightReservationMutation) ReservationNumber() (r string, exists bool) {
	v := m.reservation_number
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationNumber returns the old "reservation_number" field's value of the FlightReservation entity.
// If the FlightReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightReservationMutation) OldReservationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationNumber: %w", err)
	}
	return oldValue.ReservationNumber, nil
}

// ResetReservationNumber resets all changes to the "reservation_number" field.
func (m *FlightReservationMutation) ResetReservationNumber() {
	m.reservation_number = nil
}

// SetReservationStatus sets the "reservation_status" field.
func (m *FlightReservationMutation) SetReservationStatus(es enums.ReservationStatus) {
	m.reservation_status = &es
}

// ReservationStatus returns the value of the "reservation_status" field in the mutation.
func (m *FlightReservationMutation) ReservationStatus() (r enums.ReservationStatus, exists bool) {
	v := m.reservation_status
	if v == nil {
		return
	}
	return *v, true
}

// OldReservationStatus returns the old "reservation_status" field's value of the FlightReservation entity.
// If the FlightReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightReservationMutation) OldReservationStatus(ctx context.Context) (v enums.ReservationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReservationStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReservationStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReservationStatus: %w", err)
	}
	return oldValue.ReservationStatus, nil
}

// ResetReservationStatus resets all changes to the "reservation_status" field.
func (m *FlightReservationMutation) ResetReservationStatus() {
	m.reservation_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightReservationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightReservationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlightReservation entity.
// If the FlightReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightReservationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightReservationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightReservationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightReservationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlightReservation entity.
// If the FlightReservation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightReservationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightReservationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFlightInstanceID sets the "flight_instance" edge to the FlightInstance entity by id.
func (m *FlightReservationMutation) SetFlightInstanceID(id uuid.UUID) {
	m.flight_instance = &id
}

// ClearFlightInstance clears the "flight_instance" edge to the FlightInstance entity.
func (m *FlightReservationMutation) ClearFlightInstance() {
	m.clearedflight_instance = true
}

// FlightInstanceCleared reports if the "flight_instance" edge to the FlightInstance entity was cleared.
func (m *FlightReservationMutation) FlightInstanceCleared() bool {
	return m.clearedflight_instance
}

// FlightInstanceID returns the "flight_instance" edge ID in the mutation.
func (m *FlightReservationMutation) FlightInstanceID() (id uuid.UUID, exists bool) {
	if m.flight_instance != nil {
		return *m.flight_instance, true
	}
	return
}

// FlightInstanceIDs returns the "flight_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightInstanceID instead. It exists only for internal usage by the builders.
func (m *FlightReservationMutation) FlightInstanceIDs() (ids []uuid.UUID) {
	if id := m.flight_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightInstance resets all changes to the "flight_instance" edge.
func (m *FlightReservationMutation) ResetFlightInstance() {
	m.flight_instance = nil
	m.clearedflight_instance = false
}

// SetIteneraryID sets the "itenerary" edge to the Itenerary entity by id.
func (m *FlightReservationMutation) SetIteneraryID(id uuid.UUID) {
	m.itenerary = &id
}

// ClearItenerary clears the "itenerary" edge to the Itenerary entity.
func (m *FlightReservationMutation) ClearItenerary() {
	m.cleareditenerary = true
}

// IteneraryCleared reports if the "itenerary" edge to the Itenerary entity was cleared.
func (m *FlightReservationMutation) IteneraryCleared() bool {
	return m.cleareditenerary
}

// IteneraryID returns the "itenerary" edge ID in the mutation.
func (m *FlightReservationMutation) IteneraryID() (id uuid.UUID, exists bool) {
	if m.itenerary != nil {
		return *m.itenerary, true
	}
	return
}

// IteneraryIDs returns the "itenerary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IteneraryID instead. It exists only for internal usage by the builders.
func (m *FlightReservationMutation) IteneraryIDs() (ids []uuid.UUID) {
	if id := m.itenerary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItenerary resets all changes to the "itenerary" edge.
func (m *FlightReservationMutation) ResetItenerary() {
	m.itenerary = nil
	m.cleareditenerary = false
}

// AddPassengerIDs adds the "passengers" edge to the Passenger entity by ids.
func (m *FlightReservationMutation) AddPassengerIDs(ids ...uuid.UUID) {
	if m.passengers == nil {
		m.passengers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.passengers[ids[i]] = struct{}{}
	}
}

// ClearPassengers clears the "passengers" edge to the Passenger entity.
func (m *FlightReservationMutation) ClearPassengers() {
	m.clearedpassengers = true
}

// PassengersCleared reports if the "passengers" edge to the Passenger entity was cleared.
func (m *FlightReservationMutation) PassengersCleared() bool {
	return m.clearedpassengers
}

// RemovePassengerIDs removes the "passengers" edge to the Passenger entity by IDs.
func (m *FlightReservationMutation) RemovePassengerIDs(ids ...uuid.UUID) {
	if m.removedpassengers == nil {
		m.removedpassengers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.passengers, ids[i])
		m.removedpassengers[ids[i]] = struct{}{}
	}
}

// RemovedPassengers returns the removed IDs of the "passengers" edge to the Passenger entity.
func (m *FlightReservationMutation) RemovedPassengersIDs() (ids []uuid.UUID) {
	for id := range m.removedpassengers {
		ids = append(ids, id)
	}
	return
}

// PassengersIDs returns the "passengers" edge IDs in the mutation.
func (m *FlightReservationMutation) PassengersIDs() (ids []uuid.UUID) {
	for id := range m.passengers {
		ids = append(ids, id)
	}
	return
}

// ResetPassengers resets all changes to the "passengers" edge.
func (m *FlightReservationMutation) ResetPassengers() {
	m.passengers = nil
	m.clearedpassengers = false
	m.removedpassengers = nil
}

// Where appends a list predicates to the FlightReservationMutation builder.
func (m *FlightReservationMutation) Where(ps ...predicate.FlightReservation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlightReservationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlightReservation).
func (m *FlightReservationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightReservationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.reservation_number != nil {
		fields = append(fields, flightreservation.FieldReservationNumber)
	}
	if m.reservation_status != nil {
		fields = append(fields, flightreservation.FieldReservationStatus)
	}
	if m.created_at != nil {
		fields = append(fields, flightreservation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flightreservation.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightReservationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flightreservation.FieldReservationNumber:
		return m.ReservationNumber()
	case flightreservation.FieldReservationStatus:
		return m.ReservationStatus()
	case flightreservation.FieldCreatedAt:
		return m.CreatedAt()
	case flightreservation.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightReservationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flightreservation.FieldReservationNumber:
		return m.OldReservationNumber(ctx)
	case flightreservation.FieldReservationStatus:
		return m.OldReservationStatus(ctx)
	case flightreservation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flightreservation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FlightReservation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightReservationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flightreservation.FieldReservationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationNumber(v)
		return nil
	case flightreservation.FieldReservationStatus:
		v, ok := value.(enums.ReservationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReservationStatus(v)
		return nil
	case flightreservation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flightreservation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FlightReservation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightReservationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightReservationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightReservationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlightReservation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightReservationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightReservationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightReservationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlightReservation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightReservationMutation) ResetField(name string) error {
	switch name {
	case flightreservation.FieldReservationNumber:
		m.ResetReservationNumber()
		return nil
	case flightreservation.FieldReservationStatus:
		m.ResetReservationStatus()
		return nil
	case flightreservation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flightreservation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FlightReservation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightReservationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flight_instance != nil {
		edges = append(edges, flightreservation.EdgeFlightInstance)
	}
	if m.itenerary != nil {
		edges = append(edges, flightreservation.EdgeItenerary)
	}
	if m.passengers != nil {
		edges = append(edges, flightreservation.EdgePassengers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightReservationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flightreservation.EdgeFlightInstance:
		if id := m.flight_instance; id != nil {
			return []ent.Value{*id}
		}
	case flightreservation.EdgeItenerary:
		if id := m.itenerary; id != nil {
			return []ent.Value{*id}
		}
	case flightreservation.EdgePassengers:
		ids := make([]ent.Value, 0, len(m.passengers))
		for id := range m.passengers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightReservationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedpassengers != nil {
		edges = append(edges, flightreservation.EdgePassengers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightReservationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flightreservation.EdgePassengers:
		ids := make([]ent.Value, 0, len(m.removedpassengers))
		for id := range m.removedpassengers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightReservationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflight_instance {
		edges = append(edges, flightreservation.EdgeFlightInstance)
	}
	if m.cleareditenerary {
		edges = append(edges, flightreservation.EdgeItenerary)
	}
	if m.clearedpassengers {
		edges = append(edges, flightreservation.EdgePassengers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightReservationMutation) EdgeCleared(name string) bool {
	switch name {
	case flightreservation.EdgeFlightInstance:
		return m.clearedflight_instance
	case flightreservation.EdgeItenerary:
		return m.cleareditenerary
	case flightreservation.EdgePassengers:
		return m.clearedpassengers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightReservationMutation) ClearEdge(name string) error {
	switch name {
	case flightreservation.EdgeFlightInstance:
		m.ClearFlightInstance()
		return nil
	case flightreservation.EdgeItenerary:
		m.ClearItenerary()
		return nil
	}
	return fmt.Errorf("unknown FlightReservation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightReservationMutation) ResetEdge(name string) error {
	switch name {
	case flightreservation.EdgeFlightInstance:
		m.ResetFlightInstance()
		return nil
	case flightreservation.EdgeItenerary:
		m.ResetItenerary()
		return nil
	case flightreservation.EdgePassengers:
		m.ResetPassengers()
		return nil
	}
	return fmt.Errorf("unknown FlightReservation edge %s", name)
}

// FlightScheduleMutation represents an operation that mutates the FlightSchedule nodes in the graph.
type FlightScheduleMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	week_day                *customtypes.WeekDay
	addweek_day             *customtypes.WeekDay
	schedule_type           *enums.FlightScheduleType
	custom_date             *customtypes.Date
	departs_at              *customtypes.Time
	arrives_at              *customtypes.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	flight                  *uuid.UUID
	clearedflight           bool
	flight_instances        map[uuid.UUID]struct{}
	removedflight_instances map[uuid.UUID]struct{}
	clearedflight_instances bool
	done                    bool
	oldValue                func(context.Context) (*FlightSchedule, error)
	predicates              []predicate.FlightSchedule
}

var _ ent.Mutation = (*FlightScheduleMutation)(nil)

// flightscheduleOption allows management of the mutation configuration using functional options.
type flightscheduleOption func(*FlightScheduleMutation)

// newFlightScheduleMutation creates new mutation for the FlightSchedule entity.
func newFlightScheduleMutation(c config, op Op, opts ...flightscheduleOption) *FlightScheduleMutation {
	m := &FlightScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeFlightSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightScheduleID sets the ID field of the mutation.
func withFlightScheduleID(id uuid.UUID) flightscheduleOption {
	return func(m *FlightScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *FlightSchedule
		)
		m.oldValue = func(ctx context.Context) (*FlightSchedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlightSchedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlightSchedule sets the old FlightSchedule of the mutation.
func withFlightSchedule(node *FlightSchedule) flightscheduleOption {
	return func(m *FlightScheduleMutation) {
		m.oldValue = func(context.Context) (*FlightSchedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlightSchedule entities.
func (m *FlightScheduleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightScheduleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightScheduleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlightSchedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWeekDay sets the "week_day" field.
func (m *FlightScheduleMutation) SetWeekDay(cd customtypes.WeekDay) {
	m.week_day = &cd
	m.addweek_day = nil
}

// WeekDay returns the value of the "week_day" field in the mutation.
func (m *FlightScheduleMutation) WeekDay() (r customtypes.WeekDay, exists bool) {
	v := m.week_day
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekDay returns the old "week_day" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldWeekDay(ctx context.Context) (v customtypes.WeekDay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekDay: %w", err)
	}
	return oldValue.WeekDay, nil
}

// AddWeekDay adds cd to the "week_day" field.
func (m *FlightScheduleMutation) AddWeekDay(cd customtypes.WeekDay) {
	if m.addweek_day != nil {
		*m.addweek_day += cd
	} else {
		m.addweek_day = &cd
	}
}

// AddedWeekDay returns the value that was added to the "week_day" field in this mutation.
func (m *FlightScheduleMutation) AddedWeekDay() (r customtypes.WeekDay, exists bool) {
	v := m.addweek_day
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeekDay clears the value of the "week_day" field.
func (m *FlightScheduleMutation) ClearWeekDay() {
	m.week_day = nil
	m.addweek_day = nil
	m.clearedFields[flightschedule.FieldWeekDay] = struct{}{}
}

// WeekDayCleared returns if the "week_day" field was cleared in this mutation.
func (m *FlightScheduleMutation) WeekDayCleared() bool {
	_, ok := m.clearedFields[flightschedule.FieldWeekDay]
	return ok
}

// ResetWeekDay resets all changes to the "week_day" field.
func (m *FlightScheduleMutation) ResetWeekDay() {
	m.week_day = nil
	m.addweek_day = nil
	delete(m.clearedFields, flightschedule.FieldWeekDay)
}

// SetScheduleType sets the "schedule_type" field.
func (m *FlightScheduleMutation) SetScheduleType(est enums.FlightScheduleType) {
	m.schedule_type = &est
}

// ScheduleType returns the value of the "schedule_type" field in the mutation.
func (m *FlightScheduleMutation) ScheduleType() (r enums.FlightScheduleType, exists bool) {
	v := m.schedule_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduleType returns the old "schedule_type" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldScheduleType(ctx context.Context) (v enums.FlightScheduleType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduleType: %w", err)
	}
	return oldValue.ScheduleType, nil
}

// ResetScheduleType resets all changes to the "schedule_type" field.
func (m *FlightScheduleMutation) ResetScheduleType() {
	m.schedule_type = nil
}

// SetCustomDate sets the "custom_date" field.
func (m *FlightScheduleMutation) SetCustomDate(c customtypes.Date) {
	m.custom_date = &c
}

// CustomDate returns the value of the "custom_date" field in the mutation.
func (m *FlightScheduleMutation) CustomDate() (r customtypes.Date, exists bool) {
	v := m.custom_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomDate returns the old "custom_date" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldCustomDate(ctx context.Context) (v customtypes.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomDate: %w", err)
	}
	return oldValue.CustomDate, nil
}

// ClearCustomDate clears the value of the "custom_date" field.
func (m *FlightScheduleMutation) ClearCustomDate() {
	m.custom_date = nil
	m.clearedFields[flightschedule.FieldCustomDate] = struct{}{}
}

// CustomDateCleared returns if the "custom_date" field was cleared in this mutation.
func (m *FlightScheduleMutation) CustomDateCleared() bool {
	_, ok := m.clearedFields[flightschedule.FieldCustomDate]
	return ok
}

// ResetCustomDate resets all changes to the "custom_date" field.
func (m *FlightScheduleMutation) ResetCustomDate() {
	m.custom_date = nil
	delete(m.clearedFields, flightschedule.FieldCustomDate)
}

// SetDepartsAt sets the "departs_at" field.
func (m *FlightScheduleMutation) SetDepartsAt(c customtypes.Time) {
	m.departs_at = &c
}

// DepartsAt returns the value of the "departs_at" field in the mutation.
func (m *FlightScheduleMutation) DepartsAt() (r customtypes.Time, exists bool) {
	v := m.departs_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartsAt returns the old "departs_at" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldDepartsAt(ctx context.Context) (v customtypes.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartsAt: %w", err)
	}
	return oldValue.DepartsAt, nil
}

// ResetDepartsAt resets all changes to the "departs_at" field.
func (m *FlightScheduleMutation) ResetDepartsAt() {
	m.departs_at = nil
}

// SetArrivesAt sets the "arrives_at" field.
func (m *FlightScheduleMutation) SetArrivesAt(c customtypes.Time) {
	m.arrives_at = &c
}

// ArrivesAt returns the value of the "arrives_at" field in the mutation.
func (m *FlightScheduleMutation) ArrivesAt() (r customtypes.Time, exists bool) {
	v := m.arrives_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivesAt returns the old "arrives_at" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldArrivesAt(ctx context.Context) (v customtypes.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivesAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivesAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivesAt: %w", err)
	}
	return oldValue.ArrivesAt, nil
}

// ResetArrivesAt resets all changes to the "arrives_at" field.
func (m *FlightScheduleMutation) ResetArrivesAt() {
	m.arrives_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightScheduleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightScheduleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightScheduleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightScheduleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightScheduleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlightSchedule entity.
// If the FlightSchedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightScheduleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightScheduleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFlightID sets the "flight" edge to the Flight entity by id.
func (m *FlightScheduleMutation) SetFlightID(id uuid.UUID) {
	m.flight = &id
}

// ClearFlight clears the "flight" edge to the Flight entity.
func (m *FlightScheduleMutation) ClearFlight() {
	m.clearedflight = true
}

// FlightCleared reports if the "flight" edge to the Flight entity was cleared.
func (m *FlightScheduleMutation) FlightCleared() bool {
	return m.clearedflight
}

// FlightID returns the "flight" edge ID in the mutation.
func (m *FlightScheduleMutation) FlightID() (id uuid.UUID, exists bool) {
	if m.flight != nil {
		return *m.flight, true
	}
	return
}

// FlightIDs returns the "flight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightID instead. It exists only for internal usage by the builders.
func (m *FlightScheduleMutation) FlightIDs() (ids []uuid.UUID) {
	if id := m.flight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlight resets all changes to the "flight" edge.
func (m *FlightScheduleMutation) ResetFlight() {
	m.flight = nil
	m.clearedflight = false
}

// AddFlightInstanceIDs adds the "flight_instances" edge to the FlightInstance entity by ids.
func (m *FlightScheduleMutation) AddFlightInstanceIDs(ids ...uuid.UUID) {
	if m.flight_instances == nil {
		m.flight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_instances[ids[i]] = struct{}{}
	}
}

// ClearFlightInstances clears the "flight_instances" edge to the FlightInstance entity.
func (m *FlightScheduleMutation) ClearFlightInstances() {
	m.clearedflight_instances = true
}

// FlightInstancesCleared reports if the "flight_instances" edge to the FlightInstance entity was cleared.
func (m *FlightScheduleMutation) FlightInstancesCleared() bool {
	return m.clearedflight_instances
}

// RemoveFlightInstanceIDs removes the "flight_instances" edge to the FlightInstance entity by IDs.
func (m *FlightScheduleMutation) RemoveFlightInstanceIDs(ids ...uuid.UUID) {
	if m.removedflight_instances == nil {
		m.removedflight_instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_instances, ids[i])
		m.removedflight_instances[ids[i]] = struct{}{}
	}
}

// RemovedFlightInstances returns the removed IDs of the "flight_instances" edge to the FlightInstance entity.
func (m *FlightScheduleMutation) RemovedFlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_instances {
		ids = append(ids, id)
	}
	return
}

// FlightInstancesIDs returns the "flight_instances" edge IDs in the mutation.
func (m *FlightScheduleMutation) FlightInstancesIDs() (ids []uuid.UUID) {
	for id := range m.flight_instances {
		ids = append(ids, id)
	}
	return
}

// ResetFlightInstances resets all changes to the "flight_instances" edge.
func (m *FlightScheduleMutation) ResetFlightInstances() {
	m.flight_instances = nil
	m.clearedflight_instances = false
	m.removedflight_instances = nil
}

// Where appends a list predicates to the FlightScheduleMutation builder.
func (m *FlightScheduleMutation) Where(ps ...predicate.FlightSchedule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlightScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlightSchedule).
func (m *FlightScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightScheduleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.week_day != nil {
		fields = append(fields, flightschedule.FieldWeekDay)
	}
	if m.schedule_type != nil {
		fields = append(fields, flightschedule.FieldScheduleType)
	}
	if m.custom_date != nil {
		fields = append(fields, flightschedule.FieldCustomDate)
	}
	if m.departs_at != nil {
		fields = append(fields, flightschedule.FieldDepartsAt)
	}
	if m.arrives_at != nil {
		fields = append(fields, flightschedule.FieldArrivesAt)
	}
	if m.created_at != nil {
		fields = append(fields, flightschedule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flightschedule.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flightschedule.FieldWeekDay:
		return m.WeekDay()
	case flightschedule.FieldScheduleType:
		return m.ScheduleType()
	case flightschedule.FieldCustomDate:
		return m.CustomDate()
	case flightschedule.FieldDepartsAt:
		return m.DepartsAt()
	case flightschedule.FieldArrivesAt:
		return m.ArrivesAt()
	case flightschedule.FieldCreatedAt:
		return m.CreatedAt()
	case flightschedule.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flightschedule.FieldWeekDay:
		return m.OldWeekDay(ctx)
	case flightschedule.FieldScheduleType:
		return m.OldScheduleType(ctx)
	case flightschedule.FieldCustomDate:
		return m.OldCustomDate(ctx)
	case flightschedule.FieldDepartsAt:
		return m.OldDepartsAt(ctx)
	case flightschedule.FieldArrivesAt:
		return m.OldArrivesAt(ctx)
	case flightschedule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flightschedule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FlightSchedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flightschedule.FieldWeekDay:
		v, ok := value.(customtypes.WeekDay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekDay(v)
		return nil
	case flightschedule.FieldScheduleType:
		v, ok := value.(enums.FlightScheduleType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduleType(v)
		return nil
	case flightschedule.FieldCustomDate:
		v, ok := value.(customtypes.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomDate(v)
		return nil
	case flightschedule.FieldDepartsAt:
		v, ok := value.(customtypes.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartsAt(v)
		return nil
	case flightschedule.FieldArrivesAt:
		v, ok := value.(customtypes.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivesAt(v)
		return nil
	case flightschedule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flightschedule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addweek_day != nil {
		fields = append(fields, flightschedule.FieldWeekDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flightschedule.FieldWeekDay:
		return m.AddedWeekDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flightschedule.FieldWeekDay:
		v, ok := value.(customtypes.WeekDay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekDay(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightScheduleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flightschedule.FieldWeekDay) {
		fields = append(fields, flightschedule.FieldWeekDay)
	}
	if m.FieldCleared(flightschedule.FieldCustomDate) {
		fields = append(fields, flightschedule.FieldCustomDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightScheduleMutation) ClearField(name string) error {
	switch name {
	case flightschedule.FieldWeekDay:
		m.ClearWeekDay()
		return nil
	case flightschedule.FieldCustomDate:
		m.ClearCustomDate()
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightScheduleMutation) ResetField(name string) error {
	switch name {
	case flightschedule.FieldWeekDay:
		m.ResetWeekDay()
		return nil
	case flightschedule.FieldScheduleType:
		m.ResetScheduleType()
		return nil
	case flightschedule.FieldCustomDate:
		m.ResetCustomDate()
		return nil
	case flightschedule.FieldDepartsAt:
		m.ResetDepartsAt()
		return nil
	case flightschedule.FieldArrivesAt:
		m.ResetArrivesAt()
		return nil
	case flightschedule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flightschedule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flight != nil {
		edges = append(edges, flightschedule.EdgeFlight)
	}
	if m.flight_instances != nil {
		edges = append(edges, flightschedule.EdgeFlightInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flightschedule.EdgeFlight:
		if id := m.flight; id != nil {
			return []ent.Value{*id}
		}
	case flightschedule.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.flight_instances))
		for id := range m.flight_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflight_instances != nil {
		edges = append(edges, flightschedule.EdgeFlightInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flightschedule.EdgeFlightInstances:
		ids := make([]ent.Value, 0, len(m.removedflight_instances))
		for id := range m.removedflight_instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflight {
		edges = append(edges, flightschedule.EdgeFlight)
	}
	if m.clearedflight_instances {
		edges = append(edges, flightschedule.EdgeFlightInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case flightschedule.EdgeFlight:
		return m.clearedflight
	case flightschedule.EdgeFlightInstances:
		return m.clearedflight_instances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightScheduleMutation) ClearEdge(name string) error {
	switch name {
	case flightschedule.EdgeFlight:
		m.ClearFlight()
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightScheduleMutation) ResetEdge(name string) error {
	switch name {
	case flightschedule.EdgeFlight:
		m.ResetFlight()
		return nil
	case flightschedule.EdgeFlightInstances:
		m.ResetFlightInstances()
		return nil
	}
	return fmt.Errorf("unknown FlightSchedule edge %s", name)
}

// FlightSeatMutation represents an operation that mutates the FlightSeat nodes in the graph.
type FlightSeatMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	fare                   *float64
	addfare                *float64
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	flight_instance        *uuid.UUID
	clearedflight_instance bool
	seat                   *uuid.UUID
	clearedseat            bool
	passenger              *uuid.UUID
	clearedpassenger       bool
	done                   bool
	oldValue               func(context.Context) (*FlightSeat, error)
	predicates             []predicate.FlightSeat
}

var _ ent.Mutation = (*FlightSeatMutation)(nil)

// flightseatOption allows management of the mutation configuration using functional options.
type flightseatOption func(*FlightSeatMutation)

// newFlightSeatMutation creates new mutation for the FlightSeat entity.
func newFlightSeatMutation(c config, op Op, opts ...flightseatOption) *FlightSeatMutation {
	m := &FlightSeatMutation{
		config:        c,
		op:            op,
		typ:           TypeFlightSeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightSeatID sets the ID field of the mutation.
func withFlightSeatID(id uuid.UUID) flightseatOption {
	return func(m *FlightSeatMutation) {
		var (
			err   error
			once  sync.Once
			value *FlightSeat
		)
		m.oldValue = func(ctx context.Context) (*FlightSeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlightSeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlightSeat sets the old FlightSeat of the mutation.
func withFlightSeat(node *FlightSeat) flightseatOption {
	return func(m *FlightSeatMutation) {
		m.oldValue = func(context.Context) (*FlightSeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightSeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightSeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FlightSeat entities.
func (m *FlightSeatMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightSeatMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightSeatMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlightSeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFare sets the "fare" field.
func (m *FlightSeatMutation) SetFare(f float64) {
	m.fare = &f
	m.addfare = nil
}

// Fare returns the value of the "fare" field in the mutation.
func (m *FlightSeatMutation) Fare() (r float64, exists bool) {
	v := m.fare
	if v == nil {
		return
	}
	return *v, true
}

// OldFare returns the old "fare" field's value of the FlightSeat entity.
// If the FlightSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightSeatMutation) OldFare(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFare: %w", err)
	}
	return oldValue.Fare, nil
}

// AddFare adds f to the "fare" field.
func (m *FlightSeatMutation) AddFare(f float64) {
	if m.addfare != nil {
		*m.addfare += f
	} else {
		m.addfare = &f
	}
}

// AddedFare returns the value that was added to the "fare" field in this mutation.
func (m *FlightSeatMutation) AddedFare() (r float64, exists bool) {
	v := m.addfare
	if v == nil {
		return
	}
	return *v, true
}

// ResetFare resets all changes to the "fare" field.
func (m *FlightSeatMutation) ResetFare() {
	m.fare = nil
	m.addfare = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightSeatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightSeatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FlightSeat entity.
// If the FlightSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightSeatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightSeatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightSeatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightSeatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FlightSeat entity.
// If the FlightSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightSeatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightSeatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFlightInstanceID sets the "flight_instance" edge to the FlightInstance entity by id.
func (m *FlightSeatMutation) SetFlightInstanceID(id uuid.UUID) {
	m.flight_instance = &id
}

// ClearFlightInstance clears the "flight_instance" edge to the FlightInstance entity.
func (m *FlightSeatMutation) ClearFlightInstance() {
	m.clearedflight_instance = true
}

// FlightInstanceCleared reports if the "flight_instance" edge to the FlightInstance entity was cleared.
func (m *FlightSeatMutation) FlightInstanceCleared() bool {
	return m.clearedflight_instance
}

// FlightInstanceID returns the "flight_instance" edge ID in the mutation.
func (m *FlightSeatMutation) FlightInstanceID() (id uuid.UUID, exists bool) {
	if m.flight_instance != nil {
		return *m.flight_instance, true
	}
	return
}

// FlightInstanceIDs returns the "flight_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightInstanceID instead. It exists only for internal usage by the builders.
func (m *FlightSeatMutation) FlightInstanceIDs() (ids []uuid.UUID) {
	if id := m.flight_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightInstance resets all changes to the "flight_instance" edge.
func (m *FlightSeatMutation) ResetFlightInstance() {
	m.flight_instance = nil
	m.clearedflight_instance = false
}

// SetSeatID sets the "seat" edge to the Seat entity by id.
func (m *FlightSeatMutation) SetSeatID(id uuid.UUID) {
	m.seat = &id
}

// ClearSeat clears the "seat" edge to the Seat entity.
func (m *FlightSeatMutation) ClearSeat() {
	m.clearedseat = true
}

// SeatCleared reports if the "seat" edge to the Seat entity was cleared.
func (m *FlightSeatMutation) SeatCleared() bool {
	return m.clearedseat
}

// SeatID returns the "seat" edge ID in the mutation.
func (m *FlightSeatMutation) SeatID() (id uuid.UUID, exists bool) {
	if m.seat != nil {
		return *m.seat, true
	}
	return
}

// SeatIDs returns the "seat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeatID instead. It exists only for internal usage by the builders.
func (m *FlightSeatMutation) SeatIDs() (ids []uuid.UUID) {
	if id := m.seat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeat resets all changes to the "seat" edge.
func (m *FlightSeatMutation) ResetSeat() {
	m.seat = nil
	m.clearedseat = false
}

// SetPassengerID sets the "passenger" edge to the Passenger entity by id.
func (m *FlightSeatMutation) SetPassengerID(id uuid.UUID) {
	m.passenger = &id
}

// ClearPassenger clears the "passenger" edge to the Passenger entity.
func (m *FlightSeatMutation) ClearPassenger() {
	m.clearedpassenger = true
}

// PassengerCleared reports if the "passenger" edge to the Passenger entity was cleared.
func (m *FlightSeatMutation) PassengerCleared() bool {
	return m.clearedpassenger
}

// PassengerID returns the "passenger" edge ID in the mutation.
func (m *FlightSeatMutation) PassengerID() (id uuid.UUID, exists bool) {
	if m.passenger != nil {
		return *m.passenger, true
	}
	return
}

// PassengerIDs returns the "passenger" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PassengerID instead. It exists only for internal usage by the builders.
func (m *FlightSeatMutation) PassengerIDs() (ids []uuid.UUID) {
	if id := m.passenger; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPassenger resets all changes to the "passenger" edge.
func (m *FlightSeatMutation) ResetPassenger() {
	m.passenger = nil
	m.clearedpassenger = false
}

// Where appends a list predicates to the FlightSeatMutation builder.
func (m *FlightSeatMutation) Where(ps ...predicate.FlightSeat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlightSeatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlightSeat).
func (m *FlightSeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightSeatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.fare != nil {
		fields = append(fields, flightseat.FieldFare)
	}
	if m.created_at != nil {
		fields = append(fields, flightseat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flightseat.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightSeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flightseat.FieldFare:
		return m.Fare()
	case flightseat.FieldCreatedAt:
		return m.CreatedAt()
	case flightseat.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightSeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flightseat.FieldFare:
		return m.OldFare(ctx)
	case flightseat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flightseat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FlightSeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightSeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flightseat.FieldFare:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFare(v)
		return nil
	case flightseat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flightseat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightSeatMutation) AddedFields() []string {
	var fields []string
	if m.addfare != nil {
		fields = append(fields, flightseat.FieldFare)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightSeatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flightseat.FieldFare:
		return m.AddedFare()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightSeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flightseat.FieldFare:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFare(v)
		return nil
	}
	return fmt.Errorf("unknown FlightSeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightSeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightSeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightSeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlightSeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightSeatMutation) ResetField(name string) error {
	switch name {
	case flightseat.FieldFare:
		m.ResetFare()
		return nil
	case flightseat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flightseat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightSeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.flight_instance != nil {
		edges = append(edges, flightseat.EdgeFlightInstance)
	}
	if m.seat != nil {
		edges = append(edges, flightseat.EdgeSeat)
	}
	if m.passenger != nil {
		edges = append(edges, flightseat.EdgePassenger)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightSeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flightseat.EdgeFlightInstance:
		if id := m.flight_instance; id != nil {
			return []ent.Value{*id}
		}
	case flightseat.EdgeSeat:
		if id := m.seat; id != nil {
			return []ent.Value{*id}
		}
	case flightseat.EdgePassenger:
		if id := m.passenger; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightSeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightSeatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightSeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedflight_instance {
		edges = append(edges, flightseat.EdgeFlightInstance)
	}
	if m.clearedseat {
		edges = append(edges, flightseat.EdgeSeat)
	}
	if m.clearedpassenger {
		edges = append(edges, flightseat.EdgePassenger)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightSeatMutation) EdgeCleared(name string) bool {
	switch name {
	case flightseat.EdgeFlightInstance:
		return m.clearedflight_instance
	case flightseat.EdgeSeat:
		return m.clearedseat
	case flightseat.EdgePassenger:
		return m.clearedpassenger
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightSeatMutation) ClearEdge(name string) error {
	switch name {
	case flightseat.EdgeFlightInstance:
		m.ClearFlightInstance()
		return nil
	case flightseat.EdgeSeat:
		m.ClearSeat()
		return nil
	case flightseat.EdgePassenger:
		m.ClearPassenger()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightSeatMutation) ResetEdge(name string) error {
	switch name {
	case flightseat.EdgeFlightInstance:
		m.ResetFlightInstance()
		return nil
	case flightseat.EdgeSeat:
		m.ResetSeat()
		return nil
	case flightseat.EdgePassenger:
		m.ResetPassenger()
		return nil
	}
	return fmt.Errorf("unknown FlightSeat edge %s", name)
}

// FrontDeskMutation represents an operation that mutates the FrontDesk nodes in the graph.
type FrontDeskMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	employee_id    *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	airport        *uuid.UUID
	clearedairport bool
	done           bool
	oldValue       func(context.Context) (*FrontDesk, error)
	predicates     []predicate.FrontDesk
}

var _ ent.Mutation = (*FrontDeskMutation)(nil)

// frontdeskOption allows management of the mutation configuration using functional options.
type frontdeskOption func(*FrontDeskMutation)

// newFrontDeskMutation creates new mutation for the FrontDesk entity.
func newFrontDeskMutation(c config, op Op, opts ...frontdeskOption) *FrontDeskMutation {
	m := &FrontDeskMutation{
		config:        c,
		op:            op,
		typ:           TypeFrontDesk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFrontDeskID sets the ID field of the mutation.
func withFrontDeskID(id uuid.UUID) frontdeskOption {
	return func(m *FrontDeskMutation) {
		var (
			err   error
			once  sync.Once
			value *FrontDesk
		)
		m.oldValue = func(ctx context.Context) (*FrontDesk, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FrontDesk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFrontDesk sets the old FrontDesk of the mutation.
func withFrontDesk(node *FrontDesk) frontdeskOption {
	return func(m *FrontDeskMutation) {
		m.oldValue = func(context.Context) (*FrontDesk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FrontDeskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FrontDeskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FrontDesk entities.
func (m *FrontDeskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FrontDeskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FrontDeskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FrontDesk.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *FrontDeskMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *FrontDeskMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the FrontDesk entity.
// If the FrontDesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontDeskMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *FrontDeskMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FrontDeskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FrontDeskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FrontDesk entity.
// If the FrontDesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontDeskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FrontDeskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FrontDeskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FrontDeskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FrontDesk entity.
// If the FrontDesk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FrontDeskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FrontDeskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *FrontDeskMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *FrontDeskMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FrontDeskMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *FrontDeskMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FrontDeskMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FrontDeskMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAirportID sets the "airport" edge to the Airport entity by id.
func (m *FrontDeskMutation) SetAirportID(id uuid.UUID) {
	m.airport = &id
}

// ClearAirport clears the "airport" edge to the Airport entity.
func (m *FrontDeskMutation) ClearAirport() {
	m.clearedairport = true
}

// AirportCleared reports if the "airport" edge to the Airport entity was cleared.
func (m *FrontDeskMutation) AirportCleared() bool {
	return m.clearedairport
}

// AirportID returns the "airport" edge ID in the mutation.
func (m *FrontDeskMutation) AirportID() (id uuid.UUID, exists bool) {
	if m.airport != nil {
		return *m.airport, true
	}
	return
}

// AirportIDs returns the "airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirportID instead. It exists only for internal usage by the builders.
func (m *FrontDeskMutation) AirportIDs() (ids []uuid.UUID) {
	if id := m.airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirport resets all changes to the "airport" edge.
func (m *FrontDeskMutation) ResetAirport() {
	m.airport = nil
	m.clearedairport = false
}

// Where appends a list predicates to the FrontDeskMutation builder.
func (m *FrontDeskMutation) Where(ps ...predicate.FrontDesk) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FrontDeskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FrontDesk).
func (m *FrontDeskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FrontDeskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.employee_id != nil {
		fields = append(fields, frontdesk.FieldEmployeeID)
	}
	if m.created_at != nil {
		fields = append(fields, frontdesk.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, frontdesk.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FrontDeskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case frontdesk.FieldEmployeeID:
		return m.EmployeeID()
	case frontdesk.FieldCreatedAt:
		return m.CreatedAt()
	case frontdesk.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FrontDeskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case frontdesk.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case frontdesk.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case frontdesk.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FrontDesk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrontDeskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case frontdesk.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case frontdesk.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case frontdesk.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FrontDesk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FrontDeskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FrontDeskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FrontDeskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FrontDesk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FrontDeskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FrontDeskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FrontDeskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FrontDesk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FrontDeskMutation) ResetField(name string) error {
	switch name {
	case frontdesk.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case frontdesk.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case frontdesk.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FrontDesk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FrontDeskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, frontdesk.EdgeUser)
	}
	if m.airport != nil {
		edges = append(edges, frontdesk.EdgeAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FrontDeskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case frontdesk.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case frontdesk.EdgeAirport:
		if id := m.airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FrontDeskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FrontDeskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FrontDeskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, frontdesk.EdgeUser)
	}
	if m.clearedairport {
		edges = append(edges, frontdesk.EdgeAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FrontDeskMutation) EdgeCleared(name string) bool {
	switch name {
	case frontdesk.EdgeUser:
		return m.cleareduser
	case frontdesk.EdgeAirport:
		return m.clearedairport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FrontDeskMutation) ClearEdge(name string) error {
	switch name {
	case frontdesk.EdgeUser:
		m.ClearUser()
		return nil
	case frontdesk.EdgeAirport:
		m.ClearAirport()
		return nil
	}
	return fmt.Errorf("unknown FrontDesk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FrontDeskMutation) ResetEdge(name string) error {
	switch name {
	case frontdesk.EdgeUser:
		m.ResetUser()
		return nil
	case frontdesk.EdgeAirport:
		m.ResetAirport()
		return nil
	}
	return fmt.Errorf("unknown FrontDesk edge %s", name)
}

// IteneraryMutation represents an operation that mutates the Itenerary nodes in the graph.
type IteneraryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	clearedFields              map[string]struct{}
	flight_reservations        map[uuid.UUID]struct{}
	removedflight_reservations map[uuid.UUID]struct{}
	clearedflight_reservations bool
	customer                   *uuid.UUID
	clearedcustomer            bool
	origin_airport             *uuid.UUID
	clearedorigin_airport      bool
	destination_airport        *uuid.UUID
	cleareddestination_airport bool
	done                       bool
	oldValue                   func(context.Context) (*Itenerary, error)
	predicates                 []predicate.Itenerary
}

var _ ent.Mutation = (*IteneraryMutation)(nil)

// iteneraryOption allows management of the mutation configuration using functional options.
type iteneraryOption func(*IteneraryMutation)

// newIteneraryMutation creates new mutation for the Itenerary entity.
func newIteneraryMutation(c config, op Op, opts ...iteneraryOption) *IteneraryMutation {
	m := &IteneraryMutation{
		config:        c,
		op:            op,
		typ:           TypeItenerary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIteneraryID sets the ID field of the mutation.
func withIteneraryID(id uuid.UUID) iteneraryOption {
	return func(m *IteneraryMutation) {
		var (
			err   error
			once  sync.Once
			value *Itenerary
		)
		m.oldValue = func(ctx context.Context) (*Itenerary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Itenerary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withItenerary sets the old Itenerary of the mutation.
func withItenerary(node *Itenerary) iteneraryOption {
	return func(m *IteneraryMutation) {
		m.oldValue = func(context.Context) (*Itenerary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IteneraryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IteneraryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Itenerary entities.
func (m *IteneraryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IteneraryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IteneraryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Itenerary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *IteneraryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *IteneraryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Itenerary entity.
// If the Itenerary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IteneraryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *IteneraryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *IteneraryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *IteneraryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Itenerary entity.
// If the Itenerary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IteneraryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *IteneraryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddFlightReservationIDs adds the "flight_reservations" edge to the FlightReservation entity by ids.
func (m *IteneraryMutation) AddFlightReservationIDs(ids ...uuid.UUID) {
	if m.flight_reservations == nil {
		m.flight_reservations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.flight_reservations[ids[i]] = struct{}{}
	}
}

// ClearFlightReservations clears the "flight_reservations" edge to the FlightReservation entity.
func (m *IteneraryMutation) ClearFlightReservations() {
	m.clearedflight_reservations = true
}

// FlightReservationsCleared reports if the "flight_reservations" edge to the FlightReservation entity was cleared.
func (m *IteneraryMutation) FlightReservationsCleared() bool {
	return m.clearedflight_reservations
}

// RemoveFlightReservationIDs removes the "flight_reservations" edge to the FlightReservation entity by IDs.
func (m *IteneraryMutation) RemoveFlightReservationIDs(ids ...uuid.UUID) {
	if m.removedflight_reservations == nil {
		m.removedflight_reservations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.flight_reservations, ids[i])
		m.removedflight_reservations[ids[i]] = struct{}{}
	}
}

// RemovedFlightReservations returns the removed IDs of the "flight_reservations" edge to the FlightReservation entity.
func (m *IteneraryMutation) RemovedFlightReservationsIDs() (ids []uuid.UUID) {
	for id := range m.removedflight_reservations {
		ids = append(ids, id)
	}
	return
}

// FlightReservationsIDs returns the "flight_reservations" edge IDs in the mutation.
func (m *IteneraryMutation) FlightReservationsIDs() (ids []uuid.UUID) {
	for id := range m.flight_reservations {
		ids = append(ids, id)
	}
	return
}

// ResetFlightReservations resets all changes to the "flight_reservations" edge.
func (m *IteneraryMutation) ResetFlightReservations() {
	m.flight_reservations = nil
	m.clearedflight_reservations = false
	m.removedflight_reservations = nil
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *IteneraryMutation) SetCustomerID(id uuid.UUID) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *IteneraryMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *IteneraryMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *IteneraryMutation) CustomerID() (id uuid.UUID, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *IteneraryMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *IteneraryMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetOriginAirportID sets the "origin_airport" edge to the Airport entity by id.
func (m *IteneraryMutation) SetOriginAirportID(id uuid.UUID) {
	m.origin_airport = &id
}

// ClearOriginAirport clears the "origin_airport" edge to the Airport entity.
func (m *IteneraryMutation) ClearOriginAirport() {
	m.clearedorigin_airport = true
}

// OriginAirportCleared reports if the "origin_airport" edge to the Airport entity was cleared.
func (m *IteneraryMutation) OriginAirportCleared() bool {
	return m.clearedorigin_airport
}

// OriginAirportID returns the "origin_airport" edge ID in the mutation.
func (m *IteneraryMutation) OriginAirportID() (id uuid.UUID, exists bool) {
	if m.origin_airport != nil {
		return *m.origin_airport, true
	}
	return
}

// OriginAirportIDs returns the "origin_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginAirportID instead. It exists only for internal usage by the builders.
func (m *IteneraryMutation) OriginAirportIDs() (ids []uuid.UUID) {
	if id := m.origin_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginAirport resets all changes to the "origin_airport" edge.
func (m *IteneraryMutation) ResetOriginAirport() {
	m.origin_airport = nil
	m.clearedorigin_airport = false
}

// SetDestinationAirportID sets the "destination_airport" edge to the Airport entity by id.
func (m *IteneraryMutation) SetDestinationAirportID(id uuid.UUID) {
	m.destination_airport = &id
}

// ClearDestinationAirport clears the "destination_airport" edge to the Airport entity.
func (m *IteneraryMutation) ClearDestinationAirport() {
	m.cleareddestination_airport = true
}

// DestinationAirportCleared reports if the "destination_airport" edge to the Airport entity was cleared.
func (m *IteneraryMutation) DestinationAirportCleared() bool {
	return m.cleareddestination_airport
}

// DestinationAirportID returns the "destination_airport" edge ID in the mutation.
func (m *IteneraryMutation) DestinationAirportID() (id uuid.UUID, exists bool) {
	if m.destination_airport != nil {
		return *m.destination_airport, true
	}
	return
}

// DestinationAirportIDs returns the "destination_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DestinationAirportID instead. It exists only for internal usage by the builders.
func (m *IteneraryMutation) DestinationAirportIDs() (ids []uuid.UUID) {
	if id := m.destination_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDestinationAirport resets all changes to the "destination_airport" edge.
func (m *IteneraryMutation) ResetDestinationAirport() {
	m.destination_airport = nil
	m.cleareddestination_airport = false
}

// Where appends a list predicates to the IteneraryMutation builder.
func (m *IteneraryMutation) Where(ps ...predicate.Itenerary) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IteneraryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Itenerary).
func (m *IteneraryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IteneraryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, itenerary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, itenerary.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IteneraryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case itenerary.FieldCreatedAt:
		return m.CreatedAt()
	case itenerary.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IteneraryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case itenerary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case itenerary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Itenerary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IteneraryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case itenerary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case itenerary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Itenerary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IteneraryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IteneraryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IteneraryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Itenerary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IteneraryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IteneraryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IteneraryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Itenerary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IteneraryMutation) ResetField(name string) error {
	switch name {
	case itenerary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case itenerary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Itenerary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IteneraryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.flight_reservations != nil {
		edges = append(edges, itenerary.EdgeFlightReservations)
	}
	if m.customer != nil {
		edges = append(edges, itenerary.EdgeCustomer)
	}
	if m.origin_airport != nil {
		edges = append(edges, itenerary.EdgeOriginAirport)
	}
	if m.destination_airport != nil {
		edges = append(edges, itenerary.EdgeDestinationAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IteneraryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case itenerary.EdgeFlightReservations:
		ids := make([]ent.Value, 0, len(m.flight_reservations))
		for id := range m.flight_reservations {
			ids = append(ids, id)
		}
		return ids
	case itenerary.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case itenerary.EdgeOriginAirport:
		if id := m.origin_airport; id != nil {
			return []ent.Value{*id}
		}
	case itenerary.EdgeDestinationAirport:
		if id := m.destination_airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IteneraryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedflight_reservations != nil {
		edges = append(edges, itenerary.EdgeFlightReservations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IteneraryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case itenerary.EdgeFlightReservations:
		ids := make([]ent.Value, 0, len(m.removedflight_reservations))
		for id := range m.removedflight_reservations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IteneraryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedflight_reservations {
		edges = append(edges, itenerary.EdgeFlightReservations)
	}
	if m.clearedcustomer {
		edges = append(edges, itenerary.EdgeCustomer)
	}
	if m.clearedorigin_airport {
		edges = append(edges, itenerary.EdgeOriginAirport)
	}
	if m.cleareddestination_airport {
		edges = append(edges, itenerary.EdgeDestinationAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IteneraryMutation) EdgeCleared(name string) bool {
	switch name {
	case itenerary.EdgeFlightReservations:
		return m.clearedflight_reservations
	case itenerary.EdgeCustomer:
		return m.clearedcustomer
	case itenerary.EdgeOriginAirport:
		return m.clearedorigin_airport
	case itenerary.EdgeDestinationAirport:
		return m.cleareddestination_airport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IteneraryMutation) ClearEdge(name string) error {
	switch name {
	case itenerary.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case itenerary.EdgeOriginAirport:
		m.ClearOriginAirport()
		return nil
	case itenerary.EdgeDestinationAirport:
		m.ClearDestinationAirport()
		return nil
	}
	return fmt.Errorf("unknown Itenerary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IteneraryMutation) ResetEdge(name string) error {
	switch name {
	case itenerary.EdgeFlightReservations:
		m.ResetFlightReservations()
		return nil
	case itenerary.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case itenerary.EdgeOriginAirport:
		m.ResetOriginAirport()
		return nil
	case itenerary.EdgeDestinationAirport:
		m.ResetDestinationAirport()
		return nil
	}
	return fmt.Errorf("unknown Itenerary edge %s", name)
}

// PassengerMutation represents an operation that mutates the Passenger nodes in the graph.
type PassengerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	firstname                 *string
	lastname                  *string
	age                       *int
	addage                    *int
	nationality               *string
	passport_number           *string
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	flight_reservation        *uuid.UUID
	clearedflight_reservation bool
	flight_seat               *uuid.UUID
	clearedflight_seat        bool
	done                      bool
	oldValue                  func(context.Context) (*Passenger, error)
	predicates                []predicate.Passenger
}

var _ ent.Mutation = (*PassengerMutation)(nil)

// passengerOption allows management of the mutation configuration using functional options.
type passengerOption func(*PassengerMutation)

// newPassengerMutation creates new mutation for the Passenger entity.
func newPassengerMutation(c config, op Op, opts ...passengerOption) *PassengerMutation {
	m := &PassengerMutation{
		config:        c,
		op:            op,
		typ:           TypePassenger,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPassengerID sets the ID field of the mutation.
func withPassengerID(id uuid.UUID) passengerOption {
	return func(m *PassengerMutation) {
		var (
			err   error
			once  sync.Once
			value *Passenger
		)
		m.oldValue = func(ctx context.Context) (*Passenger, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Passenger.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPassenger sets the old Passenger of the mutation.
func withPassenger(node *Passenger) passengerOption {
	return func(m *PassengerMutation) {
		m.oldValue = func(context.Context) (*Passenger, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PassengerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PassengerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Passenger entities.
func (m *PassengerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PassengerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PassengerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Passenger.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstname sets the "firstname" field.
func (m *PassengerMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *PassengerMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *PassengerMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *PassengerMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *PassengerMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *PassengerMutation) ResetLastname() {
	m.lastname = nil
}

// SetAge sets the "age" field.
func (m *PassengerMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *PassengerMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *PassengerMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *PassengerMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *PassengerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetNationality sets the "nationality" field.
func (m *PassengerMutation) SetNationality(s string) {
	m.nationality = &s
}

// Nationality returns the value of the "nationality" field in the mutation.
func (m *PassengerMutation) Nationality() (r string, exists bool) {
	v := m.nationality
	if v == nil {
		return
	}
	return *v, true
}

// OldNationality returns the old "nationality" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldNationality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationality: %w", err)
	}
	return oldValue.Nationality, nil
}

// ResetNationality resets all changes to the "nationality" field.
func (m *PassengerMutation) ResetNationality() {
	m.nationality = nil
}

// SetPassportNumber sets the "passport_number" field.
func (m *PassengerMutation) SetPassportNumber(s string) {
	m.passport_number = &s
}

// PassportNumber returns the value of the "passport_number" field in the mutation.
func (m *PassengerMutation) PassportNumber() (r string, exists bool) {
	v := m.passport_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPassportNumber returns the old "passport_number" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldPassportNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassportNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassportNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassportNumber: %w", err)
	}
	return oldValue.PassportNumber, nil
}

// ResetPassportNumber resets all changes to the "passport_number" field.
func (m *PassengerMutation) ResetPassportNumber() {
	m.passport_number = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PassengerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PassengerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PassengerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PassengerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PassengerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Passenger entity.
// If the Passenger object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PassengerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PassengerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFlightReservationID sets the "flight_reservation" edge to the FlightReservation entity by id.
func (m *PassengerMutation) SetFlightReservationID(id uuid.UUID) {
	m.flight_reservation = &id
}

// ClearFlightReservation clears the "flight_reservation" edge to the FlightReservation entity.
func (m *PassengerMutation) ClearFlightReservation() {
	m.clearedflight_reservation = true
}

// FlightReservationCleared reports if the "flight_reservation" edge to the FlightReservation entity was cleared.
func (m *PassengerMutation) FlightReservationCleared() bool {
	return m.clearedflight_reservation
}

// FlightReservationID returns the "flight_reservation" edge ID in the mutation.
func (m *PassengerMutation) FlightReservationID() (id uuid.UUID, exists bool) {
	if m.flight_reservation != nil {
		return *m.flight_reservation, true
	}
	return
}

// FlightReservationIDs returns the "flight_reservation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightReservationID instead. It exists only for internal usage by the builders.
func (m *PassengerMutation) FlightReservationIDs() (ids []uuid.UUID) {
	if id := m.flight_reservation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightReservation resets all changes to the "flight_reservation" edge.
func (m *PassengerMutation) ResetFlightReservation() {
	m.flight_reservation = nil
	m.clearedflight_reservation = false
}

// SetFlightSeatID sets the "flight_seat" edge to the FlightSeat entity by id.
func (m *PassengerMutation) SetFlightSeatID(id uuid.UUID) {
	m.flight_seat = &id
}

// ClearFlightSeat clears the "flight_seat" edge to the FlightSeat entity.
func (m *PassengerMutation) ClearFlightSeat() {
	m.clearedflight_seat = true
}

// FlightSeatCleared reports if the "flight_seat" edge to the FlightSeat entity was cleared.
func (m *PassengerMutation) FlightSeatCleared() bool {
	return m.clearedflight_seat
}

// FlightSeatID returns the "flight_seat" edge ID in the mutation.
func (m *PassengerMutation) FlightSeatID() (id uuid.UUID, exists bool) {
	if m.flight_seat != nil {
		return *m.flight_seat, true
	}
	return
}

// FlightSeatIDs returns the "flight_seat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightSeatID instead. It exists only for internal usage by the builders.
func (m *PassengerMutation) FlightSeatIDs() (ids []uuid.UUID) {
	if id := m.flight_seat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightSeat resets all changes to the "flight_seat" edge.
func (m *PassengerMutation) ResetFlightSeat() {
	m.flight_seat = nil
	m.clearedflight_seat = false
}

// Where appends a list predicates to the PassengerMutation builder.
func (m *PassengerMutation) Where(ps ...predicate.Passenger) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PassengerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Passenger).
func (m *PassengerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PassengerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.firstname != nil {
		fields = append(fields, passenger.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, passenger.FieldLastname)
	}
	if m.age != nil {
		fields = append(fields, passenger.FieldAge)
	}
	if m.nationality != nil {
		fields = append(fields, passenger.FieldNationality)
	}
	if m.passport_number != nil {
		fields = append(fields, passenger.FieldPassportNumber)
	}
	if m.created_at != nil {
		fields = append(fields, passenger.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, passenger.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PassengerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case passenger.FieldFirstname:
		return m.Firstname()
	case passenger.FieldLastname:
		return m.Lastname()
	case passenger.FieldAge:
		return m.Age()
	case passenger.FieldNationality:
		return m.Nationality()
	case passenger.FieldPassportNumber:
		return m.PassportNumber()
	case passenger.FieldCreatedAt:
		return m.CreatedAt()
	case passenger.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PassengerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case passenger.FieldFirstname:
		return m.OldFirstname(ctx)
	case passenger.FieldLastname:
		return m.OldLastname(ctx)
	case passenger.FieldAge:
		return m.OldAge(ctx)
	case passenger.FieldNationality:
		return m.OldNationality(ctx)
	case passenger.FieldPassportNumber:
		return m.OldPassportNumber(ctx)
	case passenger.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case passenger.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Passenger field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case passenger.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case passenger.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case passenger.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case passenger.FieldNationality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationality(v)
		return nil
	case passenger.FieldPassportNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassportNumber(v)
		return nil
	case passenger.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case passenger.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PassengerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, passenger.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PassengerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case passenger.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PassengerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case passenger.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Passenger numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PassengerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PassengerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PassengerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Passenger nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PassengerMutation) ResetField(name string) error {
	switch name {
	case passenger.FieldFirstname:
		m.ResetFirstname()
		return nil
	case passenger.FieldLastname:
		m.ResetLastname()
		return nil
	case passenger.FieldAge:
		m.ResetAge()
		return nil
	case passenger.FieldNationality:
		m.ResetNationality()
		return nil
	case passenger.FieldPassportNumber:
		m.ResetPassportNumber()
		return nil
	case passenger.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case passenger.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Passenger field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PassengerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.flight_reservation != nil {
		edges = append(edges, passenger.EdgeFlightReservation)
	}
	if m.flight_seat != nil {
		edges = append(edges, passenger.EdgeFlightSeat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PassengerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case passenger.EdgeFlightReservation:
		if id := m.flight_reservation; id != nil {
			return []ent.Value{*id}
		}
	case passenger.EdgeFlightSeat:
		if id := m.flight_seat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PassengerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PassengerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PassengerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedflight_reservation {
		edges = append(edges, passenger.EdgeFlightReservation)
	}
	if m.clearedflight_seat {
		edges = append(edges, passenger.EdgeFlightSeat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PassengerMutation) EdgeCleared(name string) bool {
	switch name {
	case passenger.EdgeFlightReservation:
		return m.clearedflight_reservation
	case passenger.EdgeFlightSeat:
		return m.clearedflight_seat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PassengerMutation) ClearEdge(name string) error {
	switch name {
	case passenger.EdgeFlightReservation:
		m.ClearFlightReservation()
		return nil
	case passenger.EdgeFlightSeat:
		m.ClearFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown Passenger unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PassengerMutation) ResetEdge(name string) error {
	switch name {
	case passenger.EdgeFlightReservation:
		m.ResetFlightReservation()
		return nil
	case passenger.EdgeFlightSeat:
		m.ResetFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown Passenger edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	permission    *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	roles         map[uuid.UUID]struct{}
	removedroles  map[uuid.UUID]struct{}
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Permission, error)
	predicates    []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uuid.UUID) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPermission sets the "permission" field.
func (m *PermissionMutation) SetPermission(s string) {
	m.permission = &s
}

// Permission returns the value of the "permission" field in the mutation.
func (m *PermissionMutation) Permission() (r string, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ResetPermission resets all changes to the "permission" field.
func (m *PermissionMutation) ResetPermission() {
	m.permission = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.permission != nil {
		fields = append(fields, permission.FieldPermission)
	}
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldPermission:
		return m.Permission()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldPermission:
		return m.OldPermission(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldPermission:
		m.ResetPermission()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// PilotMutation represents an operation that mutates the Pilot nodes in the graph.
type PilotMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	employee_id        *string
	licence_number     *string
	flight_hours       *int
	addflight_hours    *int
	is_license_revoked *bool
	is_under_probation *bool
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	user               *uuid.UUID
	cleareduser        bool
	airline            *uuid.UUID
	clearedairline     bool
	done               bool
	oldValue           func(context.Context) (*Pilot, error)
	predicates         []predicate.Pilot
}

var _ ent.Mutation = (*PilotMutation)(nil)

// pilotOption allows management of the mutation configuration using functional options.
type pilotOption func(*PilotMutation)

// newPilotMutation creates new mutation for the Pilot entity.
func newPilotMutation(c config, op Op, opts ...pilotOption) *PilotMutation {
	m := &PilotMutation{
		config:        c,
		op:            op,
		typ:           TypePilot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPilotID sets the ID field of the mutation.
func withPilotID(id uuid.UUID) pilotOption {
	return func(m *PilotMutation) {
		var (
			err   error
			once  sync.Once
			value *Pilot
		)
		m.oldValue = func(ctx context.Context) (*Pilot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pilot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPilot sets the old Pilot of the mutation.
func withPilot(node *Pilot) pilotOption {
	return func(m *PilotMutation) {
		m.oldValue = func(context.Context) (*Pilot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PilotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PilotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pilot entities.
func (m *PilotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PilotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PilotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pilot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *PilotMutation) SetEmployeeID(s string) {
	m.employee_id = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *PilotMutation) EmployeeID() (r string, exists bool) {
	v := m.employee_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *PilotMutation) ResetEmployeeID() {
	m.employee_id = nil
}

// SetLicenceNumber sets the "licence_number" field.
func (m *PilotMutation) SetLicenceNumber(s string) {
	m.licence_number = &s
}

// LicenceNumber returns the value of the "licence_number" field in the mutation.
func (m *PilotMutation) LicenceNumber() (r string, exists bool) {
	v := m.licence_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenceNumber returns the old "licence_number" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldLicenceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenceNumber: %w", err)
	}
	return oldValue.LicenceNumber, nil
}

// ResetLicenceNumber resets all changes to the "licence_number" field.
func (m *PilotMutation) ResetLicenceNumber() {
	m.licence_number = nil
}

// SetFlightHours sets the "flight_hours" field.
func (m *PilotMutation) SetFlightHours(i int) {
	m.flight_hours = &i
	m.addflight_hours = nil
}

// FlightHours returns the value of the "flight_hours" field in the mutation.
func (m *PilotMutation) FlightHours() (r int, exists bool) {
	v := m.flight_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightHours returns the old "flight_hours" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldFlightHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightHours: %w", err)
	}
	return oldValue.FlightHours, nil
}

// AddFlightHours adds i to the "flight_hours" field.
func (m *PilotMutation) AddFlightHours(i int) {
	if m.addflight_hours != nil {
		*m.addflight_hours += i
	} else {
		m.addflight_hours = &i
	}
}

// AddedFlightHours returns the value that was added to the "flight_hours" field in this mutation.
func (m *PilotMutation) AddedFlightHours() (r int, exists bool) {
	v := m.addflight_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetFlightHours resets all changes to the "flight_hours" field.
func (m *PilotMutation) ResetFlightHours() {
	m.flight_hours = nil
	m.addflight_hours = nil
}

// SetIsLicenseRevoked sets the "is_license_revoked" field.
func (m *PilotMutation) SetIsLicenseRevoked(b bool) {
	m.is_license_revoked = &b
}

// IsLicenseRevoked returns the value of the "is_license_revoked" field in the mutation.
func (m *PilotMutation) IsLicenseRevoked() (r bool, exists bool) {
	v := m.is_license_revoked
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLicenseRevoked returns the old "is_license_revoked" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldIsLicenseRevoked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLicenseRevoked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLicenseRevoked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLicenseRevoked: %w", err)
	}
	return oldValue.IsLicenseRevoked, nil
}

// ResetIsLicenseRevoked resets all changes to the "is_license_revoked" field.
func (m *PilotMutation) ResetIsLicenseRevoked() {
	m.is_license_revoked = nil
}

// SetIsUnderProbation sets the "is_under_probation" field.
func (m *PilotMutation) SetIsUnderProbation(b bool) {
	m.is_under_probation = &b
}

// IsUnderProbation returns the value of the "is_under_probation" field in the mutation.
func (m *PilotMutation) IsUnderProbation() (r bool, exists bool) {
	v := m.is_under_probation
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUnderProbation returns the old "is_under_probation" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldIsUnderProbation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUnderProbation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUnderProbation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUnderProbation: %w", err)
	}
	return oldValue.IsUnderProbation, nil
}

// ResetIsUnderProbation resets all changes to the "is_under_probation" field.
func (m *PilotMutation) ResetIsUnderProbation() {
	m.is_under_probation = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PilotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PilotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PilotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PilotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PilotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pilot entity.
// If the Pilot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PilotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PilotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PilotMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PilotMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PilotMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PilotMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PilotMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PilotMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAirlineID sets the "airline" edge to the Airline entity by id.
func (m *PilotMutation) SetAirlineID(id uuid.UUID) {
	m.airline = &id
}

// ClearAirline clears the "airline" edge to the Airline entity.
func (m *PilotMutation) ClearAirline() {
	m.clearedairline = true
}

// AirlineCleared reports if the "airline" edge to the Airline entity was cleared.
func (m *PilotMutation) AirlineCleared() bool {
	return m.clearedairline
}

// AirlineID returns the "airline" edge ID in the mutation.
func (m *PilotMutation) AirlineID() (id uuid.UUID, exists bool) {
	if m.airline != nil {
		return *m.airline, true
	}
	return
}

// AirlineIDs returns the "airline" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AirlineID instead. It exists only for internal usage by the builders.
func (m *PilotMutation) AirlineIDs() (ids []uuid.UUID) {
	if id := m.airline; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAirline resets all changes to the "airline" edge.
func (m *PilotMutation) ResetAirline() {
	m.airline = nil
	m.clearedairline = false
}

// Where appends a list predicates to the PilotMutation builder.
func (m *PilotMutation) Where(ps ...predicate.Pilot) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PilotMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pilot).
func (m *PilotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PilotMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.employee_id != nil {
		fields = append(fields, pilot.FieldEmployeeID)
	}
	if m.licence_number != nil {
		fields = append(fields, pilot.FieldLicenceNumber)
	}
	if m.flight_hours != nil {
		fields = append(fields, pilot.FieldFlightHours)
	}
	if m.is_license_revoked != nil {
		fields = append(fields, pilot.FieldIsLicenseRevoked)
	}
	if m.is_under_probation != nil {
		fields = append(fields, pilot.FieldIsUnderProbation)
	}
	if m.created_at != nil {
		fields = append(fields, pilot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pilot.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PilotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pilot.FieldEmployeeID:
		return m.EmployeeID()
	case pilot.FieldLicenceNumber:
		return m.LicenceNumber()
	case pilot.FieldFlightHours:
		return m.FlightHours()
	case pilot.FieldIsLicenseRevoked:
		return m.IsLicenseRevoked()
	case pilot.FieldIsUnderProbation:
		return m.IsUnderProbation()
	case pilot.FieldCreatedAt:
		return m.CreatedAt()
	case pilot.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PilotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pilot.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case pilot.FieldLicenceNumber:
		return m.OldLicenceNumber(ctx)
	case pilot.FieldFlightHours:
		return m.OldFlightHours(ctx)
	case pilot.FieldIsLicenseRevoked:
		return m.OldIsLicenseRevoked(ctx)
	case pilot.FieldIsUnderProbation:
		return m.OldIsUnderProbation(ctx)
	case pilot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pilot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Pilot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PilotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pilot.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case pilot.FieldLicenceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenceNumber(v)
		return nil
	case pilot.FieldFlightHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightHours(v)
		return nil
	case pilot.FieldIsLicenseRevoked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLicenseRevoked(v)
		return nil
	case pilot.FieldIsUnderProbation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUnderProbation(v)
		return nil
	case pilot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pilot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Pilot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PilotMutation) AddedFields() []string {
	var fields []string
	if m.addflight_hours != nil {
		fields = append(fields, pilot.FieldFlightHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PilotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pilot.FieldFlightHours:
		return m.AddedFlightHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PilotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pilot.FieldFlightHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFlightHours(v)
		return nil
	}
	return fmt.Errorf("unknown Pilot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PilotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PilotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PilotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pilot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PilotMutation) ResetField(name string) error {
	switch name {
	case pilot.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case pilot.FieldLicenceNumber:
		m.ResetLicenceNumber()
		return nil
	case pilot.FieldFlightHours:
		m.ResetFlightHours()
		return nil
	case pilot.FieldIsLicenseRevoked:
		m.ResetIsLicenseRevoked()
		return nil
	case pilot.FieldIsUnderProbation:
		m.ResetIsUnderProbation()
		return nil
	case pilot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pilot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Pilot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PilotMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, pilot.EdgeUser)
	}
	if m.airline != nil {
		edges = append(edges, pilot.EdgeAirline)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PilotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pilot.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case pilot.EdgeAirline:
		if id := m.airline; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PilotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PilotMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PilotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, pilot.EdgeUser)
	}
	if m.clearedairline {
		edges = append(edges, pilot.EdgeAirline)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PilotMutation) EdgeCleared(name string) bool {
	switch name {
	case pilot.EdgeUser:
		return m.cleareduser
	case pilot.EdgeAirline:
		return m.clearedairline
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PilotMutation) ClearEdge(name string) error {
	switch name {
	case pilot.EdgeUser:
		m.ClearUser()
		return nil
	case pilot.EdgeAirline:
		m.ClearAirline()
		return nil
	}
	return fmt.Errorf("unknown Pilot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PilotMutation) ResetEdge(name string) error {
	switch name {
	case pilot.EdgeUser:
		m.ResetUser()
		return nil
	case pilot.EdgeAirline:
		m.ResetAirline()
		return nil
	}
	return fmt.Errorf("unknown Pilot edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *enums.Role
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	users              map[uuid.UUID]struct{}
	removedusers       map[uuid.UUID]struct{}
	clearedusers       bool
	permissions        map[uuid.UUID]struct{}
	removedpermissions map[uuid.UUID]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Role, error)
	predicates         []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(e enums.Role) {
	m.name = &e
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r enums.Role, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v enums.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(enums.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	case role.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SeatMutation represents an operation that mutates the Seat nodes in the graph.
type SeatMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	seat_number        *int
	addseat_number     *int
	seat_row           *string
	seat_type          *enums.SeatType
	seat_class         *enums.SeatClass
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	aircraft           *uuid.UUID
	clearedaircraft    bool
	flight_seat        *uuid.UUID
	clearedflight_seat bool
	done               bool
	oldValue           func(context.Context) (*Seat, error)
	predicates         []predicate.Seat
}

var _ ent.Mutation = (*SeatMutation)(nil)

// seatOption allows management of the mutation configuration using functional options.
type seatOption func(*SeatMutation)

// newSeatMutation creates new mutation for the Seat entity.
func newSeatMutation(c config, op Op, opts ...seatOption) *SeatMutation {
	m := &SeatMutation{
		config:        c,
		op:            op,
		typ:           TypeSeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeatID sets the ID field of the mutation.
func withSeatID(id uuid.UUID) seatOption {
	return func(m *SeatMutation) {
		var (
			err   error
			once  sync.Once
			value *Seat
		)
		m.oldValue = func(ctx context.Context) (*Seat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Seat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeat sets the old Seat of the mutation.
func withSeat(node *Seat) seatOption {
	return func(m *SeatMutation) {
		m.oldValue = func(context.Context) (*Seat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Seat entities.
func (m *SeatMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeatMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeatMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Seat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeatNumber sets the "seat_number" field.
func (m *SeatMutation) SetSeatNumber(i int) {
	m.seat_number = &i
	m.addseat_number = nil
}

// SeatNumber returns the value of the "seat_number" field in the mutation.
func (m *SeatMutation) SeatNumber() (r int, exists bool) {
	v := m.seat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatNumber returns the old "seat_number" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldSeatNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatNumber: %w", err)
	}
	return oldValue.SeatNumber, nil
}

// AddSeatNumber adds i to the "seat_number" field.
func (m *SeatMutation) AddSeatNumber(i int) {
	if m.addseat_number != nil {
		*m.addseat_number += i
	} else {
		m.addseat_number = &i
	}
}

// AddedSeatNumber returns the value that was added to the "seat_number" field in this mutation.
func (m *SeatMutation) AddedSeatNumber() (r int, exists bool) {
	v := m.addseat_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeatNumber resets all changes to the "seat_number" field.
func (m *SeatMutation) ResetSeatNumber() {
	m.seat_number = nil
	m.addseat_number = nil
}

// SetSeatRow sets the "seat_row" field.
func (m *SeatMutation) SetSeatRow(s string) {
	m.seat_row = &s
}

// SeatRow returns the value of the "seat_row" field in the mutation.
func (m *SeatMutation) SeatRow() (r string, exists bool) {
	v := m.seat_row
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatRow returns the old "seat_row" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldSeatRow(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatRow: %w", err)
	}
	return oldValue.SeatRow, nil
}

// ResetSeatRow resets all changes to the "seat_row" field.
func (m *SeatMutation) ResetSeatRow() {
	m.seat_row = nil
}

// SetSeatType sets the "seat_type" field.
func (m *SeatMutation) SetSeatType(et enums.SeatType) {
	m.seat_type = &et
}

// SeatType returns the value of the "seat_type" field in the mutation.
func (m *SeatMutation) SeatType() (r enums.SeatType, exists bool) {
	v := m.seat_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatType returns the old "seat_type" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldSeatType(ctx context.Context) (v enums.SeatType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatType: %w", err)
	}
	return oldValue.SeatType, nil
}

// ResetSeatType resets all changes to the "seat_type" field.
func (m *SeatMutation) ResetSeatType() {
	m.seat_type = nil
}

// SetSeatClass sets the "seat_class" field.
func (m *SeatMutation) SetSeatClass(ec enums.SeatClass) {
	m.seat_class = &ec
}

// SeatClass returns the value of the "seat_class" field in the mutation.
func (m *SeatMutation) SeatClass() (r enums.SeatClass, exists bool) {
	v := m.seat_class
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatClass returns the old "seat_class" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldSeatClass(ctx context.Context) (v enums.SeatClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatClass: %w", err)
	}
	return oldValue.SeatClass, nil
}

// ResetSeatClass resets all changes to the "seat_class" field.
func (m *SeatMutation) ResetSeatClass() {
	m.seat_class = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SeatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SeatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SeatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SeatMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SeatMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Seat entity.
// If the Seat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SeatMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAircraftID sets the "aircraft" edge to the Aircraft entity by id.
func (m *SeatMutation) SetAircraftID(id uuid.UUID) {
	m.aircraft = &id
}

// ClearAircraft clears the "aircraft" edge to the Aircraft entity.
func (m *SeatMutation) ClearAircraft() {
	m.clearedaircraft = true
}

// AircraftCleared reports if the "aircraft" edge to the Aircraft entity was cleared.
func (m *SeatMutation) AircraftCleared() bool {
	return m.clearedaircraft
}

// AircraftID returns the "aircraft" edge ID in the mutation.
func (m *SeatMutation) AircraftID() (id uuid.UUID, exists bool) {
	if m.aircraft != nil {
		return *m.aircraft, true
	}
	return
}

// AircraftIDs returns the "aircraft" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AircraftID instead. It exists only for internal usage by the builders.
func (m *SeatMutation) AircraftIDs() (ids []uuid.UUID) {
	if id := m.aircraft; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAircraft resets all changes to the "aircraft" edge.
func (m *SeatMutation) ResetAircraft() {
	m.aircraft = nil
	m.clearedaircraft = false
}

// SetFlightSeatID sets the "flight_seat" edge to the FlightSeat entity by id.
func (m *SeatMutation) SetFlightSeatID(id uuid.UUID) {
	m.flight_seat = &id
}

// ClearFlightSeat clears the "flight_seat" edge to the FlightSeat entity.
func (m *SeatMutation) ClearFlightSeat() {
	m.clearedflight_seat = true
}

// FlightSeatCleared reports if the "flight_seat" edge to the FlightSeat entity was cleared.
func (m *SeatMutation) FlightSeatCleared() bool {
	return m.clearedflight_seat
}

// FlightSeatID returns the "flight_seat" edge ID in the mutation.
func (m *SeatMutation) FlightSeatID() (id uuid.UUID, exists bool) {
	if m.flight_seat != nil {
		return *m.flight_seat, true
	}
	return
}

// FlightSeatIDs returns the "flight_seat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FlightSeatID instead. It exists only for internal usage by the builders.
func (m *SeatMutation) FlightSeatIDs() (ids []uuid.UUID) {
	if id := m.flight_seat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFlightSeat resets all changes to the "flight_seat" edge.
func (m *SeatMutation) ResetFlightSeat() {
	m.flight_seat = nil
	m.clearedflight_seat = false
}

// Where appends a list predicates to the SeatMutation builder.
func (m *SeatMutation) Where(ps ...predicate.Seat) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SeatMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Seat).
func (m *SeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeatMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.seat_number != nil {
		fields = append(fields, seat.FieldSeatNumber)
	}
	if m.seat_row != nil {
		fields = append(fields, seat.FieldSeatRow)
	}
	if m.seat_type != nil {
		fields = append(fields, seat.FieldSeatType)
	}
	if m.seat_class != nil {
		fields = append(fields, seat.FieldSeatClass)
	}
	if m.created_at != nil {
		fields = append(fields, seat.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, seat.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seat.FieldSeatNumber:
		return m.SeatNumber()
	case seat.FieldSeatRow:
		return m.SeatRow()
	case seat.FieldSeatType:
		return m.SeatType()
	case seat.FieldSeatClass:
		return m.SeatClass()
	case seat.FieldCreatedAt:
		return m.CreatedAt()
	case seat.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seat.FieldSeatNumber:
		return m.OldSeatNumber(ctx)
	case seat.FieldSeatRow:
		return m.OldSeatRow(ctx)
	case seat.FieldSeatType:
		return m.OldSeatType(ctx)
	case seat.FieldSeatClass:
		return m.OldSeatClass(ctx)
	case seat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case seat.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Seat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seat.FieldSeatNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatNumber(v)
		return nil
	case seat.FieldSeatRow:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatRow(v)
		return nil
	case seat.FieldSeatType:
		v, ok := value.(enums.SeatType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatType(v)
		return nil
	case seat.FieldSeatClass:
		v, ok := value.(enums.SeatClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatClass(v)
		return nil
	case seat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case seat.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Seat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeatMutation) AddedFields() []string {
	var fields []string
	if m.addseat_number != nil {
		fields = append(fields, seat.FieldSeatNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case seat.FieldSeatNumber:
		return m.AddedSeatNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case seat.FieldSeatNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeatNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Seat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Seat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeatMutation) ResetField(name string) error {
	switch name {
	case seat.FieldSeatNumber:
		m.ResetSeatNumber()
		return nil
	case seat.FieldSeatRow:
		m.ResetSeatRow()
		return nil
	case seat.FieldSeatType:
		m.ResetSeatType()
		return nil
	case seat.FieldSeatClass:
		m.ResetSeatClass()
		return nil
	case seat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case seat.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Seat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.aircraft != nil {
		edges = append(edges, seat.EdgeAircraft)
	}
	if m.flight_seat != nil {
		edges = append(edges, seat.EdgeFlightSeat)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seat.EdgeAircraft:
		if id := m.aircraft; id != nil {
			return []ent.Value{*id}
		}
	case seat.EdgeFlightSeat:
		if id := m.flight_seat; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaircraft {
		edges = append(edges, seat.EdgeAircraft)
	}
	if m.clearedflight_seat {
		edges = append(edges, seat.EdgeFlightSeat)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeatMutation) EdgeCleared(name string) bool {
	switch name {
	case seat.EdgeAircraft:
		return m.clearedaircraft
	case seat.EdgeFlightSeat:
		return m.clearedflight_seat
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeatMutation) ClearEdge(name string) error {
	switch name {
	case seat.EdgeAircraft:
		m.ClearAircraft()
		return nil
	case seat.EdgeFlightSeat:
		m.ClearFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown Seat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeatMutation) ResetEdge(name string) error {
	switch name {
	case seat.EdgeAircraft:
		m.ResetAircraft()
		return nil
	case seat.EdgeFlightSeat:
		m.ResetFlightSeat()
		return nil
	}
	return fmt.Errorf("unknown Seat edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	firstname         *string
	lastname          *string
	email             *string
	phone             *string
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	account           *uuid.UUID
	clearedaccount    bool
	admin             *uuid.UUID
	clearedadmin      bool
	crew              *uuid.UUID
	clearedcrew       bool
	pilot             *uuid.UUID
	clearedpilot      bool
	front_desk        *uuid.UUID
	clearedfront_desk bool
	customer          *uuid.UUID
	clearedcustomer   bool
	address           *uuid.UUID
	clearedaddress    bool
	role              *uuid.UUID
	clearedrole       bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstname sets the "firstname" field.
func (m *UserMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *UserMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *UserMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *UserMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *UserMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *UserMutation) ResetLastname() {
	m.lastname = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *UserMutation) SetAccountID(id uuid.UUID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *UserMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *UserMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *UserMutation) AccountID() (id uuid.UUID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetAdminID sets the "admin" edge to the Admin entity by id.
func (m *UserMutation) SetAdminID(id uuid.UUID) {
	m.admin = &id
}

// ClearAdmin clears the "admin" edge to the Admin entity.
func (m *UserMutation) ClearAdmin() {
	m.clearedadmin = true
}

// AdminCleared reports if the "admin" edge to the Admin entity was cleared.
func (m *UserMutation) AdminCleared() bool {
	return m.clearedadmin
}

// AdminID returns the "admin" edge ID in the mutation.
func (m *UserMutation) AdminID() (id uuid.UUID, exists bool) {
	if m.admin != nil {
		return *m.admin, true
	}
	return
}

// AdminIDs returns the "admin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AdminIDs() (ids []uuid.UUID) {
	if id := m.admin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdmin resets all changes to the "admin" edge.
func (m *UserMutation) ResetAdmin() {
	m.admin = nil
	m.clearedadmin = false
}

// SetCrewID sets the "crew" edge to the Crew entity by id.
func (m *UserMutation) SetCrewID(id uuid.UUID) {
	m.crew = &id
}

// ClearCrew clears the "crew" edge to the Crew entity.
func (m *UserMutation) ClearCrew() {
	m.clearedcrew = true
}

// CrewCleared reports if the "crew" edge to the Crew entity was cleared.
func (m *UserMutation) CrewCleared() bool {
	return m.clearedcrew
}

// CrewID returns the "crew" edge ID in the mutation.
func (m *UserMutation) CrewID() (id uuid.UUID, exists bool) {
	if m.crew != nil {
		return *m.crew, true
	}
	return
}

// CrewIDs returns the "crew" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CrewID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CrewIDs() (ids []uuid.UUID) {
	if id := m.crew; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCrew resets all changes to the "crew" edge.
func (m *UserMutation) ResetCrew() {
	m.crew = nil
	m.clearedcrew = false
}

// SetPilotID sets the "pilot" edge to the Pilot entity by id.
func (m *UserMutation) SetPilotID(id uuid.UUID) {
	m.pilot = &id
}

// ClearPilot clears the "pilot" edge to the Pilot entity.
func (m *UserMutation) ClearPilot() {
	m.clearedpilot = true
}

// PilotCleared reports if the "pilot" edge to the Pilot entity was cleared.
func (m *UserMutation) PilotCleared() bool {
	return m.clearedpilot
}

// PilotID returns the "pilot" edge ID in the mutation.
func (m *UserMutation) PilotID() (id uuid.UUID, exists bool) {
	if m.pilot != nil {
		return *m.pilot, true
	}
	return
}

// PilotIDs returns the "pilot" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PilotID instead. It exists only for internal usage by the builders.
func (m *UserMutation) PilotIDs() (ids []uuid.UUID) {
	if id := m.pilot; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPilot resets all changes to the "pilot" edge.
func (m *UserMutation) ResetPilot() {
	m.pilot = nil
	m.clearedpilot = false
}

// SetFrontDeskID sets the "front_desk" edge to the FrontDesk entity by id.
func (m *UserMutation) SetFrontDeskID(id uuid.UUID) {
	m.front_desk = &id
}

// ClearFrontDesk clears the "front_desk" edge to the FrontDesk entity.
func (m *UserMutation) ClearFrontDesk() {
	m.clearedfront_desk = true
}

// FrontDeskCleared reports if the "front_desk" edge to the FrontDesk entity was cleared.
func (m *UserMutation) FrontDeskCleared() bool {
	return m.clearedfront_desk
}

// FrontDeskID returns the "front_desk" edge ID in the mutation.
func (m *UserMutation) FrontDeskID() (id uuid.UUID, exists bool) {
	if m.front_desk != nil {
		return *m.front_desk, true
	}
	return
}

// FrontDeskIDs returns the "front_desk" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FrontDeskID instead. It exists only for internal usage by the builders.
func (m *UserMutation) FrontDeskIDs() (ids []uuid.UUID) {
	if id := m.front_desk; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrontDesk resets all changes to the "front_desk" edge.
func (m *UserMutation) ResetFrontDesk() {
	m.front_desk = nil
	m.clearedfront_desk = false
}

// SetCustomerID sets the "customer" edge to the Customer entity by id.
func (m *UserMutation) SetCustomerID(id uuid.UUID) {
	m.customer = &id
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *UserMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *UserMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the "customer" edge ID in the mutation.
func (m *UserMutation) CustomerID() (id uuid.UUID, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *UserMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *UserMutation) SetAddressID(id uuid.UUID) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *UserMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *UserMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *UserMutation) AddressID() (id uuid.UUID, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AddressIDs() (ids []uuid.UUID) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// SetRoleID sets the "role" edge to the Role entity by id.
func (m *UserMutation) SetRoleID(id uuid.UUID) {
	m.role = &id
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleID returns the "role" edge ID in the mutation.
func (m *UserMutation) RoleID() (id uuid.UUID, exists bool) {
	if m.role != nil {
		return *m.role, true
	}
	return
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []uuid.UUID) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.firstname != nil {
		fields = append(fields, user.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, user.FieldLastname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirstname:
		return m.Firstname()
	case user.FieldLastname:
		return m.Lastname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirstname:
		return m.OldFirstname(ctx)
	case user.FieldLastname:
		return m.OldLastname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case user.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirstname:
		m.ResetFirstname()
		return nil
	case user.FieldLastname:
		m.ResetLastname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.account != nil {
		edges = append(edges, user.EdgeAccount)
	}
	if m.admin != nil {
		edges = append(edges, user.EdgeAdmin)
	}
	if m.crew != nil {
		edges = append(edges, user.EdgeCrew)
	}
	if m.pilot != nil {
		edges = append(edges, user.EdgePilot)
	}
	if m.front_desk != nil {
		edges = append(edges, user.EdgeFrontDesk)
	}
	if m.customer != nil {
		edges = append(edges, user.EdgeCustomer)
	}
	if m.address != nil {
		edges = append(edges, user.EdgeAddress)
	}
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAdmin:
		if id := m.admin; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCrew:
		if id := m.crew; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgePilot:
		if id := m.pilot; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeFrontDesk:
		if id := m.front_desk; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedaccount {
		edges = append(edges, user.EdgeAccount)
	}
	if m.clearedadmin {
		edges = append(edges, user.EdgeAdmin)
	}
	if m.clearedcrew {
		edges = append(edges, user.EdgeCrew)
	}
	if m.clearedpilot {
		edges = append(edges, user.EdgePilot)
	}
	if m.clearedfront_desk {
		edges = append(edges, user.EdgeFrontDesk)
	}
	if m.clearedcustomer {
		edges = append(edges, user.EdgeCustomer)
	}
	if m.clearedaddress {
		edges = append(edges, user.EdgeAddress)
	}
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAccount:
		return m.clearedaccount
	case user.EdgeAdmin:
		return m.clearedadmin
	case user.EdgeCrew:
		return m.clearedcrew
	case user.EdgePilot:
		return m.clearedpilot
	case user.EdgeFrontDesk:
		return m.clearedfront_desk
	case user.EdgeCustomer:
		return m.clearedcustomer
	case user.EdgeAddress:
		return m.clearedaddress
	case user.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeAccount:
		m.ClearAccount()
		return nil
	case user.EdgeAdmin:
		m.ClearAdmin()
		return nil
	case user.EdgeCrew:
		m.ClearCrew()
		return nil
	case user.EdgePilot:
		m.ClearPilot()
		return nil
	case user.EdgeFrontDesk:
		m.ClearFrontDesk()
		return nil
	case user.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case user.EdgeAddress:
		m.ClearAddress()
		return nil
	case user.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAccount:
		m.ResetAccount()
		return nil
	case user.EdgeAdmin:
		m.ResetAdmin()
		return nil
	case user.EdgeCrew:
		m.ResetCrew()
		return nil
	case user.EdgePilot:
		m.ResetPilot()
		return nil
	case user.EdgeFrontDesk:
		m.ResetFrontDesk()
		return nil
	case user.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case user.EdgeAddress:
		m.ResetAddress()
		return nil
	case user.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
